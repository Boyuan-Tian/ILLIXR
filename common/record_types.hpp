#pragma once

/**
 * Do not edit this file directly.
 * It is automatically generate dby record_types.py
 */

#include <chrono>
#include <vector>

namespace ILLIXR {

/**
 * @brief a light-weight RTTI discriminator for base types (fields of record types).
 *
 * Unlike [std::type_info][1], this can be used to recover the size.
 * 
 * Pointers to it can be used as type-tags which (since they are integers) are easier to store and
 * can be switch-cased.
 * 
 * [1]: https://en.cppreference.com/w/cpp/types/type_info
 */
class type {
public:
	std::size_t size;
	std::string name;
	std::size_t type_id;
	type(std::size_t size_, std::string name_, std::size_t type_id_ = 0)
		: size{size_}
		, name{name_}
		, type_id{type_id_}
	{ }
};

class struct_type : public type {
public:
	std::vector<std::pair<std::string, const type*>> fields;
	struct_type(std::size_t size_, std::string name_, std::vector<std::pair<std::string, const type*>> fields_)
		: type{size_, name_}
		, fields{fields_}
	{ }
};

class record {
public:
	virtual ~record() { }
};

namespace types {

static const type std__chrono__nanoseconds {sizeof(std::chrono::nanoseconds), std::string{"std::chrono::nanoseconds", 1}};
static const type std__size_t {sizeof(std::size_t), std::string{"std::size_t", 2}};
static const type std__string {sizeof(std::string), std::string{"std::string", 3}};

} /* namespace types */

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-private-field"

class misc_record : public record {
public:
	misc_record(std::size_t component_id_ , std::string notes_ )
		: component_id{component_id_},
		notes{notes_}
	{ }
	static const struct_type type_descr;
private:
	std::size_t component_id;
	std::string notes;
};

const struct_type misc_record::type_descr = struct_type{
	sizeof(misc_record),
	"misc_record",
	{
		{"component_id", &types::std__size_t},
		{"notes", &types::std__string}
	},
};


class component_start_record : public record {
public:
	component_start_record(std::size_t component_id_ , std::string name_ )
		: component_id{component_id_},
		name{name_}
	{ }
	static const struct_type type_descr;
private:
	std::size_t component_id;
	std::string name;
};

const struct_type component_start_record::type_descr = struct_type{
	sizeof(component_start_record),
	"component_start_record",
	{
		{"component_id", &types::std__size_t},
		{"name", &types::std__string}
	},
};


class component_stop_record : public record {
public:
	component_stop_record(std::size_t component_id_ )
		: component_id{component_id_}
	{ }
	static const struct_type type_descr;
private:
	std::size_t component_id;
};

const struct_type component_stop_record::type_descr = struct_type{
	sizeof(component_stop_record),
	"component_stop_record",
	{
		{"component_id", &types::std__size_t}
	},
};


class start_skip_iteration_record : public record {
public:
	start_skip_iteration_record(std::size_t component_id_ , std::size_t iteration_ , std::size_t skip_iteration_ )
		: component_id{component_id_},
		iteration{iteration_},
		skip_iteration{skip_iteration_},
		cpu_time{thread_cpu_time()}
	{ }
	static const struct_type type_descr;
private:
	std::size_t component_id;
	std::size_t iteration;
	std::size_t skip_iteration;
	std::chrono::nanoseconds cpu_time;
};

const struct_type start_skip_iteration_record::type_descr = struct_type{
	sizeof(start_skip_iteration_record),
	"start_skip_iteration_record",
	{
		{"component_id", &types::std__size_t},
		{"iteration", &types::std__size_t},
		{"skip_iteration", &types::std__size_t},
		{"cpu_time", &types::std__chrono__nanoseconds}
	},
};


class stop_skip_iteration_record : public record {
public:
	stop_skip_iteration_record(std::size_t component_id_ , std::size_t iteration_ , std::size_t skip_iteration_ )
		: component_id{component_id_},
		iteration{iteration_},
		skip_iteration{skip_iteration_},
		cpu_time{thread_cpu_time()}
	{ }
	static const struct_type type_descr;
private:
	std::size_t component_id;
	std::size_t iteration;
	std::size_t skip_iteration;
	std::chrono::nanoseconds cpu_time;
};

const struct_type stop_skip_iteration_record::type_descr = struct_type{
	sizeof(stop_skip_iteration_record),
	"stop_skip_iteration_record",
	{
		{"component_id", &types::std__size_t},
		{"iteration", &types::std__size_t},
		{"skip_iteration", &types::std__size_t},
		{"cpu_time", &types::std__chrono__nanoseconds}
	},
};


class start_iteration_record : public record {
public:
	start_iteration_record(std::size_t component_id_ , std::size_t iteration_ , std::size_t skip_iteration_ )
		: component_id{component_id_},
		iteration{iteration_},
		skip_iteration{skip_iteration_},
		cpu_time{thread_cpu_time()}
	{ }
	static const struct_type type_descr;
private:
	std::size_t component_id;
	std::size_t iteration;
	std::size_t skip_iteration;
	std::chrono::nanoseconds cpu_time;
};

const struct_type start_iteration_record::type_descr = struct_type{
	sizeof(start_iteration_record),
	"start_iteration_record",
	{
		{"component_id", &types::std__size_t},
		{"iteration", &types::std__size_t},
		{"skip_iteration", &types::std__size_t},
		{"cpu_time", &types::std__chrono__nanoseconds}
	},
};


class stop_iteration_record : public record {
public:
	stop_iteration_record(std::size_t component_id_ , std::size_t iteration_ , std::size_t skip_iteration_ )
		: component_id{component_id_},
		iteration{iteration_},
		skip_iteration{skip_iteration_},
		cpu_time{thread_cpu_time()}
	{ }
	static const struct_type type_descr;
private:
	std::size_t component_id;
	std::size_t iteration;
	std::size_t skip_iteration;
	std::chrono::nanoseconds cpu_time;
};

const struct_type stop_iteration_record::type_descr = struct_type{
	sizeof(stop_iteration_record),
	"stop_iteration_record",
	{
		{"component_id", &types::std__size_t},
		{"iteration", &types::std__size_t},
		{"skip_iteration", &types::std__size_t},
		{"cpu_time", &types::std__chrono__nanoseconds}
	},
};


class start_callback_record : public record {
public:
	start_callback_record(std::size_t component_id_ , std::size_t topic_id_ , std::size_t serial_no_ )
		: component_id{component_id_},
		topic_id{topic_id_},
		serial_no{serial_no_},
		cpu_time{thread_cpu_time()}
	{ }
	static const struct_type type_descr;
private:
	std::size_t component_id;
	std::size_t topic_id;
	std::size_t serial_no;
	std::chrono::nanoseconds cpu_time;
};

const struct_type start_callback_record::type_descr = struct_type{
	sizeof(start_callback_record),
	"start_callback_record",
	{
		{"component_id", &types::std__size_t},
		{"topic_id", &types::std__size_t},
		{"serial_no", &types::std__size_t},
		{"cpu_time", &types::std__chrono__nanoseconds}
	},
};


class stop_callback_record : public record {
public:
	stop_callback_record(std::size_t component_id_ , std::size_t topic_id_ , std::size_t serial_no_ )
		: component_id{component_id_},
		topic_id{topic_id_},
		serial_no{serial_no_},
		cpu_time{thread_cpu_time()}
	{ }
	static const struct_type type_descr;
private:
	std::size_t component_id;
	std::size_t topic_id;
	std::size_t serial_no;
	std::chrono::nanoseconds cpu_time;
};

const struct_type stop_callback_record::type_descr = struct_type{
	sizeof(stop_callback_record),
	"stop_callback_record",
	{
		{"component_id", &types::std__size_t},
		{"topic_id", &types::std__size_t},
		{"serial_no", &types::std__size_t},
		{"cpu_time", &types::std__chrono__nanoseconds}
	},
};


class switchboard_topic_record : public record {
public:
	switchboard_topic_record(std::size_t component_id_ , std::size_t topic_id_ , std::string type_name_ , std::string name_ , std::size_t bytes_ )
		: component_id{component_id_},
		topic_id{topic_id_},
		type_name{type_name_},
		name{name_},
		bytes{bytes_}
	{ }
	static const struct_type type_descr;
private:
	std::size_t component_id;
	std::size_t topic_id;
	std::string type_name;
	std::string name;
	std::size_t bytes;
};

const struct_type switchboard_topic_record::type_descr = struct_type{
	sizeof(switchboard_topic_record),
	"switchboard_topic_record",
	{
		{"component_id", &types::std__size_t},
		{"topic_id", &types::std__size_t},
		{"type_name", &types::std__string},
		{"name", &types::std__string},
		{"bytes", &types::std__size_t}
	},
};


class switchboard_write_record : public record {
public:
	switchboard_write_record(std::size_t component_id_ , std::size_t topic_id_ , std::size_t serial_no_ )
		: component_id{component_id_},
		topic_id{topic_id_},
		serial_no{serial_no_}
	{ }
	static const struct_type type_descr;
private:
	std::size_t component_id;
	std::size_t topic_id;
	std::size_t serial_no;
};

const struct_type switchboard_write_record::type_descr = struct_type{
	sizeof(switchboard_write_record),
	"switchboard_write_record",
	{
		{"component_id", &types::std__size_t},
		{"topic_id", &types::std__size_t},
		{"serial_no", &types::std__size_t}
	},
};


class switchboard_read_record : public record {
public:
	switchboard_read_record(std::size_t component_id_ , std::size_t topic_id_ , std::size_t serial_no_ )
		: component_id{component_id_},
		topic_id{topic_id_},
		serial_no{serial_no_}
	{ }
	static const struct_type type_descr;
private:
	std::size_t component_id;
	std::size_t topic_id;
	std::size_t serial_no;
};

const struct_type switchboard_read_record::type_descr = struct_type{
	sizeof(switchboard_read_record),
	"switchboard_read_record",
	{
		{"component_id", &types::std__size_t},
		{"topic_id", &types::std__size_t},
		{"serial_no", &types::std__size_t}
	},
};


#pragma GCC diagnostic pop
} /* namespace ILLIXR */
