from pathlib import Path
from typing import NamedTuple, Optional, List

class Field(NamedTuple):
    """C++ record_class field

    type: C++ type name
    name: C++ member name
    default: if default is None, then I get the field's value from the constructor. Otherwise, it should be an expression."""

    type: str
    name: str
    default: Optional[str]

class RecordType(NamedTuple):
    name: str
    fields: List[Field]

component = Field("std::size_t", "component_id", None)
iteration = Field("std::size_t", "iteration", None)
skip_iteration = Field("std::size_t", "skip_iteration", None)
cpu_time = Field("std::chrono::nanoseconds", "cpu_time", "thread_cpu_time()")
topic_id = Field("std::size_t", "topic_id", None)
serial_no = Field("std::size_t", "serial_no", None)
name = Field("std::string", "name", None)

record_types = [
    RecordType("misc_record", [
        component,
        Field("std::string", "notes", None),
    ]),
    RecordType("component_start_record", [
        component,
        name,
    ]),
    RecordType("component_stop_record", [
        component,
    ]),
    RecordType("start_skip_iteration_record", [
        component,
        iteration,
        skip_iteration,
        cpu_time,
    ]),
    RecordType("stop_skip_iteration_record", [
        component,
        iteration,
        skip_iteration,
        cpu_time,
    ]),
    RecordType("start_iteration_record", [
        component,
        iteration,
        skip_iteration,
        cpu_time,
    ]),
    RecordType("stop_iteration_record", [
        component,
        iteration,
        skip_iteration,
        cpu_time,
    ]),
    RecordType("start_callback_record", [
        component,
        topic_id,
        serial_no,
        cpu_time,
    ]),
    RecordType("stop_callback_record", [
        component,
        topic_id,
        serial_no,
        cpu_time,
    ]),
    RecordType("switchboard_topic_record", [
        component,
        topic_id,
        Field("std::string", "type_name", None),
        name,
        Field("std::size_t", "bytes", None)
    ]),
    RecordType("switchboard_write_record", [
        component,
        topic_id,
        serial_no,
    ]),
    RecordType("switchboard_read_record", [
        component,
        topic_id,
        serial_no,
    ]),
]

def to_cpp_name(string):
    return string.replace(":", "_")

def record_type_class(record_type):
    arg_list = ", ".join(
        f"{field.type} {field.name}_ "
        for field in record_type.fields if field.default is None
    )
    init_list = ",\n\t\t".join(
        field.name + "{" + (field.name + "_" if field.default is None else field.default) + "}"
        for field in record_type.fields
    )
    member_list = "\n\t".join(f"{field.type} {field.name};" for field in record_type.fields)

    base_type_vector = "{\n\t\t" + ",\n\t\t".join(f"{{\"{field.name}\", &types::{to_cpp_name(field.type)}}}" for field in record_type.fields) + "\n\t}"

    return f"""
class {record_type.name} : public record {{
public:
	{record_type.name}({arg_list})
		: {init_list}
	{{ }}
	static const struct_type type_descr;
private:
	{member_list}
}};

const struct_type {record_type.name}::type_descr = struct_type{{
	sizeof({record_type.name}),
	\"{record_type.name}\",
	{base_type_vector},
}};

"""

# Specifiying the path relative to __file__ means that this script will work no matter what the CWD is.
with (Path(__file__).parent / "record_types.hpp").open("w") as f:
    f.write(f"""
#pragma once

/**
 * Do not edit this file directly.
 * It is automatically generate dby record_types.py
 */

#include <chrono>
#include <vector>

namespace ILLIXR {{

/**
 * @brief a light-weight RTTI discriminator for base types (fields of record types).
 *
 * Unlike [std::type_info][1], this can be used to recover the size.
 * 
 * Pointers to it can be used as type-tags which (since they are integers) are easier to store and
 * can be switch-cased.
 * 
 * [1]: https://en.cppreference.com/w/cpp/types/type_info
 */
class type {{
public:
	std::size_t size;
	std::string name;
	std::size_t type_id;
	type(std::size_t size_, std::string name_, std::size_t type_id_ = 0)
		: size{{size_}}
		, name{{name_}}
		, type_id{{type_id_}}
	{{ }}
}};

class struct_type : public type {{
public:
	std::vector<std::pair<std::string, const type*>> fields;
	struct_type(std::size_t size_, std::string name_, std::vector<std::pair<std::string, const type*>> fields_)
		: type{{size_, name_}}
		, fields{{fields_}}
	{{ }}
}};

class record {{
public:
	virtual ~record() {{ }}
}};

namespace types {{

""".lstrip())


    base_types = sorted(set(
        # set(some_list) uniqifies some_list
        field.type
        for record_type in record_types
        for field in record_type.fields
    ))

    for i, base_type in enumerate(base_types):
        f.write(f"static const type {to_cpp_name(base_type)} {{sizeof({base_type}), std::string{{\"{base_type}\", {i+1}}}}};\n")

    f.write("""
} /* namespace types */

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-private-field"
""")

    for record_type in record_types:
        f.write(record_type_class(record_type))

    f.write("""
#pragma GCC diagnostic pop
} /* namespace ILLIXR */
""")
