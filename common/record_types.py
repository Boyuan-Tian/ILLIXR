from pathlib import Path
from collections import namedtuple

header = """
#pragma once

/**
 * Do not edit this file directly.
 * It is automatically generate dby record_types.py
 */

#include <chrono>
#include <unordered_map>
#include <vector>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-private-field"

namespace ILLIXR {
"""

field = namedtuple("field", ["type", "name", "default"])
# if default is None, then I get the field's value from the constructor
# Otherwise, it should be an expression.
record_type = namedtuple("record_type", ["name", "fields"])

component = field("std::size_t", "component_id", None)
iteration = field("std::size_t", "iteration", None)
skip_iteration = field("std::size_t", "skip_iteration", None)
cpu_time = field("std::chrono::nanoseconds", "cpu_time", "thread_cpu_time()")
topic_id = field("std::size_t", "topic_id", None)
serial_no = field("std::size_t", "serial_no", None)
name = field("std::string", "name", None)

record_types = [
    record_type("misc_record", [
        component,
        field("std::string", "notes", None),
    ]),
    record_type("component_start_record", [
        component,
        name,
    ]),
    record_type("component_stop_record", [
        component,
    ]),
    record_type("start_skip_iteration_record", [
        component,
        iteration,
        skip_iteration,
        cpu_time,
    ]),
    record_type("stop_skip_iteration_record", [
        component,
        iteration,
        skip_iteration,
        cpu_time,
    ]),
    record_type("start_iteration_record", [
        component,
        iteration,
        skip_iteration,
        cpu_time,
    ]),
    record_type("stop_iteration_record", [
        component,
        iteration,
        skip_iteration,
        cpu_time,
    ]),
    record_type("start_callback_record", [
        component,
        topic_id,
        serial_no,
        cpu_time,
    ]),
    record_type("stop_callback_record", [
        component,
        topic_id,
        serial_no,
        cpu_time,
    ]),
    record_type("switchboard_topic_record", [
        component,
        topic_id,
        field("std::string", "type_name", None),
        name,
        field("std::size_t", "bytes", None)
    ]),
    record_type("switchboard_write_record", [
        component,
        topic_id,
        serial_no,
    ]),
    record_type("switchboard_read_record", [
        component,
        topic_id,
        serial_no,
    ]),
]

def to_cpp_name(string):
    return string.replace(":", "_")

footer = """
}
#pragma GCC diagnostic pop
"""

# Specifiying the path relative to __file__ means that this script will work no matter what the CWD is.
with (Path(__file__).parent / "record_types.hpp").open("w") as f:
    f.write(header)

    record_type_id = ",\n\t".join(record_type.name for record_type in record_types)
    f.write(f"""
/**
 * @brief a light-weight RTTI discriminator for record types.
 *
 * Unlike [std::type_info][1], this is an integer, which makes it easier to store and it can be switch-cased.
 *
 * [1]: https://en.cppreference.com/w/cpp/types/type_info
 */
enum class record_type_id {{
	{record_type_id}
}};

""")

    base_types = sorted(set(
        # set(some_list) uniqifies some_list
        field.type
        for record_type in record_types
        for field in record_type.fields
    ))
    base_type_id = ",\n\t".join(map(to_cpp_name, base_types))
    f.write(f"""
/**
 * @brief a light-weight RTTI discriminator for base types (fields of record types).
 *
 * Unlike [std::type_info][1], this is an integer, which makes it easier to store and it can be switch-cased.
 *
 * [1]: https://en.cppreference.com/w/cpp/types/type_info
 */
enum class base_type_id {{
	{base_type_id}
}};

""")

    for record_type in record_types:
        arg_list = ", ".join(
            f"{field.type} {field.name}_ "
            for field in record_type.fields if field.default is None
        )
        init_list = ",\n\t\t".join(
            field.name + "{" + (field.name + "_" if field.default is None else field.default) + "}"
            for field in record_type.fields
        )
        member_list = "\n\t".join(f"{field.type} {field.name};" for field in record_type.fields)
        f.write(f"""
class {record_type.name} {{
public:
	{record_type.name}({arg_list})
		: {init_list}
	{{ }}
	static const record_type_id id = record_type_id::{record_type.name};
private:
	{member_list}
}};

""")

    f.write("""
class record_type_description {
public:
	std::size_t size;
	std::string name;
	std::vector<base_type_id> fields;
	record_type_description(std::size_t size_, std::string name_, std::vector<base_type_id> fields_)
		: size{size_}
		, name{name_}
		, fields{fields_}
	{ }
};

""")

    def to_base_type_vector(fields):
        return "{\n\t\t\t\t" + ",\n\t\t\t\t".join(f"base_type_id::{to_cpp_name(field.type)}" for field in fields) + "\n\t\t\t}\n\t\t"

    record_type_map = ",\n\t".join(
        f"{{\n\t\trecord_type_id::{record_type.name},\n\t\t{{\n\t\t\tsizeof({record_type.name}),\n\t\t\t\"{record_type.name}\",\n\t\t\t{to_base_type_vector(record_type.fields)}}}\n\t}}"
        for record_type in record_types
    )

    base_type_map = ",\n\t".join(
        f"{{base_type_id::{to_cpp_name(base_type)}, sizeof({base_type})}}"
        for base_type in base_types
    )

    f.write(f"""
/**
 * @brief A description of each record type.
 *
 * This map will help you know what to do when you get a void* record.
 */
std::unordered_map<record_type_id, record_type_description> record_type_map {{
	{record_type_map}
}};


std::unordered_map<base_type_id, std::size_t> base_type_map {{
	{base_type_map}
}};

""")

    f.write(footer)
