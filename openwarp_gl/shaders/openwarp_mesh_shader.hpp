#include <GL/gl.h>

#define GLSL_VERSION            "430 core"

const char* const timeWarpChromaticVertexProgramGLSL =
	"#version " GLSL_VERSION "\n"
	"uniform highp mat4x4 TimeWarpStartTransform;\n"
	"uniform highp mat4x4 TimeWarpEndTransform;\n"
	"in highp vec3 vertexPosition;\n"
	"in highp vec2 vertexUv0;\n"
	"in highp vec2 vertexUv1;\n"
	"in highp vec2 vertexUv2;\n"
	"out mediump vec2 fragmentUv0;\n"
	"out mediump vec2 fragmentUv1;\n"
	"out mediump vec2 fragmentUv2;\n"
	"out gl_PerVertex { vec4 gl_Position; };\n"
	"void main( void )\n"
	"{\n"
	"	gl_Position = vec4( vertexPosition, 1.0 );\n"
	"\n"
	"	float displayFraction = vertexPosition.x * 0.5 + 0.5;\n"	// landscape left-to-right
	"\n"
	"	vec3 startUv0 = (TimeWarpStartTransform * vec4( vertexUv0, -1, 1 )).xyz;\n"
	"	vec3 startUv1 = (TimeWarpStartTransform * vec4( vertexUv1, -1, 1 )).xyz;\n"
	"	vec3 startUv2 = (TimeWarpStartTransform * vec4( vertexUv2, -1, 1 )).xyz;\n"
	"\n"
	"	vec3 endUv0 = (TimeWarpEndTransform * vec4( vertexUv0, -1, 1 )).xyz;\n"
	"	vec3 endUv1 = (TimeWarpEndTransform * vec4( vertexUv1, -1, 1 )).xyz;\n"
	"	vec3 endUv2 = (TimeWarpEndTransform * vec4( vertexUv2, -1, 1 )).xyz;\n"
	"\n"
	"	vec3 curUv0 = mix( startUv0, endUv0, displayFraction );\n"
	"	vec3 curUv1 = mix( startUv1, endUv1, displayFraction );\n"
	"	vec3 curUv2 = mix( startUv2, endUv2, displayFraction );\n"
	"\n"
	"	fragmentUv0 = curUv0.xy * ( 1.0 / max( curUv0.z, 0.00001 ) );\n"
	"	fragmentUv1 = curUv1.xy * ( 1.0 / max( curUv1.z, 0.00001 ) );\n"
	"	fragmentUv2 = curUv2.xy * ( 1.0 / max( curUv2.z, 0.00001 ) );\n"
	"}\n";

const char* const timeWarpChromaticFragmentProgramGLSL =
	"#version " GLSL_VERSION "\n"
	"uniform int ArrayLayer;\n"
	"uniform highp sampler2D Texture;\n"
	"in mediump vec2 fragmentUv0;\n"
	"in mediump vec2 fragmentUv1;\n"
	"in mediump vec2 fragmentUv2;\n"
	"out lowp vec4 outColor;\n"
	"void main()\n"
	"{\n"
	"	outColor.r = texture( Texture, fragmentUv0 ).r;\n"
	"	outColor.g = texture( Texture, fragmentUv1 ).g;\n"
	"	outColor.b = texture( Texture, fragmentUv2 ).b;\n"
	"	outColor.a = 1.0;\n"
	"}\n";

const char* const meshWarpVertexProgramGLSL =
	"#version " GLSL_VERSION "\n"

	"uniform highp mat4x4 u_renderInverseP;\n"
	"uniform highp mat4x4 u_renderInverseV;\n"
	"uniform highp mat4x4 u_warpVP;\n"

	"layout(location = 0) in vec3 in_position;\n"
    "layout(location = 1) in vec2 in_uv;\n"

	"layout(binding = 0) uniform highp sampler2D Texture;\n"
	"layout(binding = 1) uniform highp sampler2D _Depth;\n"
	"out mediump vec4 test;\n"
	"out mediump vec2 warpUv;\n"
	"out gl_PerVertex { vec4 gl_Position; };\n"

	"void main( void )\n"
	"{\n"
	"	float z = textureLod(_Depth, in_uv, 0.0).x * 2.0 - 1.0;\n"

	"	float bleedRadius = 0.01;\n"
	"	float edgeTolerance = 0.01f;\n"
	"	float outlier = min(              											\n"
	"					  min(														\n"
	"							textureLod(_Depth, in_uv - vec2(bleedRadius,0), 0).x, \n"
	"							textureLod(_Depth, in_uv + vec2(bleedRadius,0), 0).x  \n"
	"					  ),														\n"
	"					  min(\n"
	"							textureLod(_Depth, in_uv - vec2(0,bleedRadius), 0).x, \n"
	"							textureLod(_Depth, in_uv + vec2(0,bleedRadius), 0).x  \n"
	"					  )\n"
	"					);\n"
	"	outlier = outlier * 2.0 - 1.0;\n"
	"	if(z - outlier > edgeTolerance){\n"
	"		z = outlier;\n"
	"	}\n"
	"	z = min(0.99, z);"
	
	"	vec4 clipSpacePosition = vec4(in_uv * 2.0 - 1.0, z, 1.0);\n"

	"	vec4 frag_viewspace = u_renderInverseP * clipSpacePosition;\n"
	"	frag_viewspace /= frag_viewspace.w;\n"
	"	vec3 frag_worldspace = (u_renderInverseV * frag_viewspace).xyz;\n"
	"	vec4 result = u_warpVP * vec4(frag_worldspace, 1.0);\n"

	"	result /= abs(result.w);\n"
	"	gl_Position = result;\n"
	"	test = vec4(in_uv,1,1);\n"
	"	warpUv = in_uv;"
	"}\n";

const char* const meshWarpFragmentProgramGLSL =
	"#version " GLSL_VERSION "\n"
	"layout(binding = 0) uniform highp sampler2D Texture;\n"
	"in mediump vec4 test;\n"
	"in mediump vec2 warpUv;\n"
	"out mediump vec4 outColor;\n"
	"void main()\n"
	"{\n"
	"	outColor.rgba = texture(Texture, warpUv);\n"
	//"	outColor.rgba = test;\n"
	// "	outColor.r = mod(test.x,0.2);\n"
	// "	outColor.g = mod(test.y,0.2);\n"
	// "	outColor.b = mod(test.z,0.2);\n"
	"}\n";