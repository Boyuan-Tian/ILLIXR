{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"building_ILLIXR/","text":"Building ILLIXR Basic usage From the project root, make run.dbg -j$(nproc) will build the ILLIXR runtime standalone, the ILLIXR plugins, and run it for you. make run.opt -j$(nproc) , is the same but with optimizations on and debug off. Adding in a new plugin (the common case) In the common case, one need only define a Makefile with the line include common/common.mk and symlink common ( ln -s ../common common ). This provides the necessary targets and uses the compiler $(CXX) , which is defined in Make based on the OS and environment variables. It compiles plugin.cpp and any other *.cpp files into the plugin. It will invoke a recompile the target any time any *.hpp or *.cpp file changes. It compiles with C++17. You can change this in your plugin by defining STDCXX = ... before the include . This change will not affect other plugins; just yours. Libraries can be added by appending to LDFLAGS and CFLAGS , for example LDFLAGS := $(LDFLAGS) $(shell pkg-config --ldflags eigen3) CFLAGS := $(CFLAGS) $(shell pkg-config --cflags eigen3) See the source for the exact flags. Adding in a new plugin (the general case) Each plugin can have a completely independent build system, as long as: - It defines a Makefile with targets for plugin.dbg.so , plugin.opt.so , and clean . Inside this Makefile , one can defer to another build system. It's compiler maintains ABI compatibility with the compilers used in every other plugin. Using the same version of Clang or GCC on the same architecture is sufficient for this. It's name is inserted in the root Makefile , in the plugins list. Philosophy Each plugin should not have to know or care how the others are compiled. In the future, they may even be distributed separately, just as SOs. Therefore, each plugin needs its own build system. Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins should be extremely easy. It should be easy to build in parallel. Always rebuild every time, so the binary is always \"fresh\". This is a great convenience when experimenting. However, this implies that rebuilding must be fast when not much has changed. Make is the de facto standard for building C/C++ programs. GNU Make, reucrsive make, and the makefile language begets no shortage of problems [ 1 , 2 , 3 , 4 , 5 ], but I chose Make for its tradeoff of between simplicity and functionality. What it lacks in functionality (compared to CMake, Ninja, scons, Bazel, Meson) it makes up for in simplicity. It's still the build system in which it is the easiest to invoke arbitrary commands in shell and the easiest to have a common.mk included in each plugin. This decision to use Make should be revisited, when this project outgrows its ability, but for now, Make remains, in my judgement, the best tool for the job .","title":"Building ILLIXR"},{"location":"building_ILLIXR/#building-illixr","text":"","title":"Building ILLIXR"},{"location":"building_ILLIXR/#basic-usage","text":"From the project root, make run.dbg -j$(nproc) will build the ILLIXR runtime standalone, the ILLIXR plugins, and run it for you. make run.opt -j$(nproc) , is the same but with optimizations on and debug off.","title":"Basic usage"},{"location":"building_ILLIXR/#adding-in-a-new-plugin-the-common-case","text":"In the common case, one need only define a Makefile with the line include common/common.mk and symlink common ( ln -s ../common common ). This provides the necessary targets and uses the compiler $(CXX) , which is defined in Make based on the OS and environment variables. It compiles plugin.cpp and any other *.cpp files into the plugin. It will invoke a recompile the target any time any *.hpp or *.cpp file changes. It compiles with C++17. You can change this in your plugin by defining STDCXX = ... before the include . This change will not affect other plugins; just yours. Libraries can be added by appending to LDFLAGS and CFLAGS , for example LDFLAGS := $(LDFLAGS) $(shell pkg-config --ldflags eigen3) CFLAGS := $(CFLAGS) $(shell pkg-config --cflags eigen3) See the source for the exact flags.","title":"Adding in a new plugin (the common case)"},{"location":"building_ILLIXR/#adding-in-a-new-plugin-the-general-case","text":"Each plugin can have a completely independent build system, as long as: - It defines a Makefile with targets for plugin.dbg.so , plugin.opt.so , and clean . Inside this Makefile , one can defer to another build system. It's compiler maintains ABI compatibility with the compilers used in every other plugin. Using the same version of Clang or GCC on the same architecture is sufficient for this. It's name is inserted in the root Makefile , in the plugins list.","title":"Adding in a new plugin (the general case)"},{"location":"building_ILLIXR/#philosophy","text":"Each plugin should not have to know or care how the others are compiled. In the future, they may even be distributed separately, just as SOs. Therefore, each plugin needs its own build system. Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins should be extremely easy. It should be easy to build in parallel. Always rebuild every time, so the binary is always \"fresh\". This is a great convenience when experimenting. However, this implies that rebuilding must be fast when not much has changed. Make is the de facto standard for building C/C++ programs. GNU Make, reucrsive make, and the makefile language begets no shortage of problems [ 1 , 2 , 3 , 4 , 5 ], but I chose Make for its tradeoff of between simplicity and functionality. What it lacks in functionality (compared to CMake, Ninja, scons, Bazel, Meson) it makes up for in simplicity. It's still the build system in which it is the easiest to invoke arbitrary commands in shell and the easiest to have a common.mk included in each plugin. This decision to use Make should be revisited, when this project outgrows its ability, but for now, Make remains, in my judgement, the best tool for the job .","title":"Philosophy"},{"location":"default_plugins/","text":"Default Plugins offline_imu_cam : Reads IMU data and images from files on disk, emulating a real sensor on the headset (with emulated timing). ground_truth_slam : Reads the ground-truth from the same dataset to compare our output against (uses timing from offline_imu_cam ). open_vins : Runs OpenVINS on the input, and outputs a the headset's pose. In practice, this publishes a fairly slow pose, so pose prediction is required to infer a fast pose. We do not yet have pose prediction, so we say open_vins also publishes a fast pose. gldemo : Renders a static scene (into left and right eyebuffers) given the pose from open_vins . timewarp_gl : Asynchronous reprojection of the eyebuffers. debugview : Renders a frame for debug information. audio : TODO: this. By default this is disabled, since it requires an NVIDIA GPU. hologram : TODO: this. By default this is disabled, since it requires an NVIDIA GPU. Below this point, I will use Switchboard terminology. Read the API documentation on switchboard for definitions. In the above figure, rectangles are plugins, cylinders are topics (the graph is bipartitioned between these two gorups). Solid arrows from plugins to topics represent publishing. Solid arrows from topics to plugins represent synchronous reading. They take some action for every event which gets published on the topic. Solid arrows from topics to plugins represent asynchronous reading. They need to know just the latest event on their topic. Imagine the topic as a trough filing with events from its publisher, being drained by its synchronous readers (AKA subscribers), while asynchronous readres just skim from the top. See writing_your_plugin.md to extend ILLIXR.","title":"Default Plugins"},{"location":"default_plugins/#default-plugins","text":"offline_imu_cam : Reads IMU data and images from files on disk, emulating a real sensor on the headset (with emulated timing). ground_truth_slam : Reads the ground-truth from the same dataset to compare our output against (uses timing from offline_imu_cam ). open_vins : Runs OpenVINS on the input, and outputs a the headset's pose. In practice, this publishes a fairly slow pose, so pose prediction is required to infer a fast pose. We do not yet have pose prediction, so we say open_vins also publishes a fast pose. gldemo : Renders a static scene (into left and right eyebuffers) given the pose from open_vins . timewarp_gl : Asynchronous reprojection of the eyebuffers. debugview : Renders a frame for debug information. audio : TODO: this. By default this is disabled, since it requires an NVIDIA GPU. hologram : TODO: this. By default this is disabled, since it requires an NVIDIA GPU. Below this point, I will use Switchboard terminology. Read the API documentation on switchboard for definitions. In the above figure, rectangles are plugins, cylinders are topics (the graph is bipartitioned between these two gorups). Solid arrows from plugins to topics represent publishing. Solid arrows from topics to plugins represent synchronous reading. They take some action for every event which gets published on the topic. Solid arrows from topics to plugins represent asynchronous reading. They need to know just the latest event on their topic. Imagine the topic as a trough filing with events from its publisher, being drained by its synchronous readers (AKA subscribers), while asynchronous readres just skim from the top. See writing_your_plugin.md to extend ILLIXR.","title":"Default Plugins"},{"location":"design/","text":"Design Spindle Switchboard Threadsafety","title":"Design"},{"location":"design/#design","text":"","title":"Design"},{"location":"design/#spindle","text":"","title":"Spindle"},{"location":"design/#switchboard","text":"","title":"Switchboard"},{"location":"design/#threadsafety","text":"","title":"Threadsafety"},{"location":"getting_started/","text":"Getting Started ILLIXR standalone The ILLIXR runtime can be built \"standalone\", to run without Monado. This mode does not support OpenXR, but it is faster for development. Clone the repository. git clone --recursive https://github.com/charmoniumQ/illixr-prototype # TODO: update this link when we move repositories Update the submodules. Submodules are git repositories inside a git repository that need to be pulled down separately. git submodule update --init --recursive Install dependencies. This script installs some Ubuntu/Debian packages and builds a specific version of OpenCV from source. ./install_deps.sh Build and run ILLIXR standalone. make run.dbg ILLIXR with Monado (supports OpenXR) Clone and build ILLIXR (same steps as standalone, except the make target is all.dbg.so ). git clone --recursive https://github.com/charmoniumQ/illixr-prototype git submodule update --init --recursive ./install_deps.sh make all.dbg.so Clone and build Monado. git clone https://github.com/ILLIXR/monado_integration.git cd monado_integration mkdir build && cd build cmake .. -DCMAKE_BUILD_TYPE=Debug -DILLIXR_PATH=../ILLIXR -G \"Unix Makefiles\" # replace ../ILLIXR with the path to ILLIXR make -j$(nproc) Clone and build our application example. git clone https://gitlab.freedesktop.org/monado/demos/openxr-simple-example cd openxr-simple-example mkdir build && cd build cmake .. make -j$(nproc) Set environment variables and run. export XR_RUNTIME_JSON=../monado_integration/build/openxr_monado-dev.json # replace ../monado_integration with the path to the previous repo export ILLIXR_PATH=../ILLIXR/runtime/plugin.dbg.so export ILLIXR_COMP=../ILLIXR/ground_truth_slam/plugin.dbg.so:../ILLIXR/offline_imu_cam/plugin.dbg.so:../ILLIXR/open_vins/plugin.dbg.so:../ILLIXR/pose_prediction/plugin.dbg.so:../ILLIXR/timewarp_gl/plugin.dbg.so:../ILLIXR/debugview/plugin.dbg.so:../ILLIXR/audio_pipeline/ # replace ../ILLIXR with the path to ILLIXR Next steps The source code is divided into the following directories: - runtime : create a runnable binary that loads every plugin. * This contains Spindle, which is responsible for loading plugins. common : resources one might use in each plugin. Most plugins symlink this directory into theirs. Contains the interface for Switchboard, which maintains event-streams (implementation is in runtime ). Contains the interface for Phonebook, which is a service-directory (implementation is in runtime ). a directory for each plugin. Almost all of the XR functionality is implemented in plugins. See default_components.md for more details. Try browsing the source of plugins. If you edit any of the source files, this make commend will detect and rebuild the respective binary. If you want to add your own, see writing_your_plugin.md","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#illixr-standalone","text":"The ILLIXR runtime can be built \"standalone\", to run without Monado. This mode does not support OpenXR, but it is faster for development. Clone the repository. git clone --recursive https://github.com/charmoniumQ/illixr-prototype # TODO: update this link when we move repositories Update the submodules. Submodules are git repositories inside a git repository that need to be pulled down separately. git submodule update --init --recursive Install dependencies. This script installs some Ubuntu/Debian packages and builds a specific version of OpenCV from source. ./install_deps.sh Build and run ILLIXR standalone. make run.dbg","title":"ILLIXR standalone"},{"location":"getting_started/#illixr-with-monado-supports-openxr","text":"Clone and build ILLIXR (same steps as standalone, except the make target is all.dbg.so ). git clone --recursive https://github.com/charmoniumQ/illixr-prototype git submodule update --init --recursive ./install_deps.sh make all.dbg.so Clone and build Monado. git clone https://github.com/ILLIXR/monado_integration.git cd monado_integration mkdir build && cd build cmake .. -DCMAKE_BUILD_TYPE=Debug -DILLIXR_PATH=../ILLIXR -G \"Unix Makefiles\" # replace ../ILLIXR with the path to ILLIXR make -j$(nproc) Clone and build our application example. git clone https://gitlab.freedesktop.org/monado/demos/openxr-simple-example cd openxr-simple-example mkdir build && cd build cmake .. make -j$(nproc) Set environment variables and run. export XR_RUNTIME_JSON=../monado_integration/build/openxr_monado-dev.json # replace ../monado_integration with the path to the previous repo export ILLIXR_PATH=../ILLIXR/runtime/plugin.dbg.so export ILLIXR_COMP=../ILLIXR/ground_truth_slam/plugin.dbg.so:../ILLIXR/offline_imu_cam/plugin.dbg.so:../ILLIXR/open_vins/plugin.dbg.so:../ILLIXR/pose_prediction/plugin.dbg.so:../ILLIXR/timewarp_gl/plugin.dbg.so:../ILLIXR/debugview/plugin.dbg.so:../ILLIXR/audio_pipeline/ # replace ../ILLIXR with the path to ILLIXR","title":"ILLIXR with Monado (supports OpenXR)"},{"location":"getting_started/#next-steps","text":"The source code is divided into the following directories: - runtime : create a runnable binary that loads every plugin. * This contains Spindle, which is responsible for loading plugins. common : resources one might use in each plugin. Most plugins symlink this directory into theirs. Contains the interface for Switchboard, which maintains event-streams (implementation is in runtime ). Contains the interface for Phonebook, which is a service-directory (implementation is in runtime ). a directory for each plugin. Almost all of the XR functionality is implemented in plugins. See default_components.md for more details. Try browsing the source of plugins. If you edit any of the source files, this make commend will detect and rebuild the respective binary. If you want to add your own, see writing_your_plugin.md","title":"Next steps"},{"location":"writing_your_plugin/","text":"Writing your plugin With this, you can extend ILLIXR for your own purposes. You can also replace any existing functionality this way. We suggest making a subdirectory in the ILLIXR repo, but one could make it anywhere. Add this directory to plugins in ILLIXR's root Makefile . The order in this list determines the order of initialization in the program. phonebook , for example, is order-sensitive. In your plugin directory, we suggest symlinking common ( ln -s ../common common ). Create a Makefile with the following contents. See building_ILLIXR.md for more details and alternative setups. include common.mk You must decide if your plugin should inherit the standardized threadloop or not. If your plugin just needs to run one computation repeatedly, then your plugin class should extend threadloop . If you need custom concurrency (more complicated than a loop), triggered concurrency (by events fired in other plugins), or no concurrency then your plugin class should extend plugin . Write a file called plugin.cpp with this body, replacing every instance of plugin_name : #include \"common/phonebook.hpp\" #include \"common/plugin.hpp\" #include \"common/threadloop.hpp\" using ILLIXR; // Inherit from `plugin` if you don't need the threadloop class plugin_name : public threadloop { public: plugin_name(phonebook* pb) { } virtual void start() override { } virtual ~plugin_name() override { } }; // This line makes the plugin importable by Spindle PLUGIN_MAIN(plugin_name); At this point, you should be able to go to the ILLIXR root and make dbg . If you edit a source file and then make dbg , it should trigger a rebuild of your plugin. This is all that is required to be a plugin which can be loaded by Spindle in the ILLIXR runtime. Reading and writing from Phonebook and Switchboard optional, but nearly every plugin does it. See default_plugins.md for more details. First, we can query the phonebook to get various services including switchboard . Then we query switchboard for event-streams (topics). We will read topic1 , write to topic2 , and schedule computation on topic 3 . See the API documentation for phonebook and switchboard for more details. #include \"common/phonebook.hpp\" #include \"common/plugin.hpp\" #include \"common/threadloop.hpp\" /* When datatypes have to be common across plugins (e.g. a phonebook service or switchboard topic), they are defined in this header, which is accessible to all plugins. */ #include \"common/data_formath.hpp\" class plugin_name : public threadloop { public: /* After the constructor, C++ permits a list of member-constructors. I use uniform initialization (curly-braces) [1] instead of parens to avoid ambiguity [2]. I put the comma at the start of the line, so that lines can be copied around or deleted freely (except for the first). [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization [2]: https://en.wikipedia.org/wiki/Most_vexing_parse */ plugin_name(phonebook* pb) // find the switchboard in phonebook : sb{pb->lookup_impl<switchboard>()} // create a handle to a topic in switchboard for subscribing , topic1{sb->subscribe_latest<topic1_type>(\"topic1\")} // create a handle to a topic in switchboard for publishing , topic2{sb->publish<topic2_type>(\"topic2\")} { // Read topic 1 topic1_type* event1 = topic1.get_latest_ro(); // Write to topic 2 topic2_type* event2 = new topic2_type; topic2.put(event2); // Read topic 3 synchronously sb->schedule<topic3_type>(\"topic3\", [&](const topic3_type *event3) { /* This is a [lambda expression][1] [1]: https://en.cppreference.com/w/cpp/language/lambda */ std::cout << \"Got a new event on topic3: \" << event3 << std::endl; }); } private: switchboard* pb std::unique_ptr<reader_latest<topic1_type>> topic1; std::unique_ptr<writer<topic2>> topic2; };","title":"Writing Your Plugin"},{"location":"writing_your_plugin/#writing-your-plugin","text":"With this, you can extend ILLIXR for your own purposes. You can also replace any existing functionality this way. We suggest making a subdirectory in the ILLIXR repo, but one could make it anywhere. Add this directory to plugins in ILLIXR's root Makefile . The order in this list determines the order of initialization in the program. phonebook , for example, is order-sensitive. In your plugin directory, we suggest symlinking common ( ln -s ../common common ). Create a Makefile with the following contents. See building_ILLIXR.md for more details and alternative setups. include common.mk You must decide if your plugin should inherit the standardized threadloop or not. If your plugin just needs to run one computation repeatedly, then your plugin class should extend threadloop . If you need custom concurrency (more complicated than a loop), triggered concurrency (by events fired in other plugins), or no concurrency then your plugin class should extend plugin . Write a file called plugin.cpp with this body, replacing every instance of plugin_name : #include \"common/phonebook.hpp\" #include \"common/plugin.hpp\" #include \"common/threadloop.hpp\" using ILLIXR; // Inherit from `plugin` if you don't need the threadloop class plugin_name : public threadloop { public: plugin_name(phonebook* pb) { } virtual void start() override { } virtual ~plugin_name() override { } }; // This line makes the plugin importable by Spindle PLUGIN_MAIN(plugin_name); At this point, you should be able to go to the ILLIXR root and make dbg . If you edit a source file and then make dbg , it should trigger a rebuild of your plugin. This is all that is required to be a plugin which can be loaded by Spindle in the ILLIXR runtime. Reading and writing from Phonebook and Switchboard optional, but nearly every plugin does it. See default_plugins.md for more details. First, we can query the phonebook to get various services including switchboard . Then we query switchboard for event-streams (topics). We will read topic1 , write to topic2 , and schedule computation on topic 3 . See the API documentation for phonebook and switchboard for more details. #include \"common/phonebook.hpp\" #include \"common/plugin.hpp\" #include \"common/threadloop.hpp\" /* When datatypes have to be common across plugins (e.g. a phonebook service or switchboard topic), they are defined in this header, which is accessible to all plugins. */ #include \"common/data_formath.hpp\" class plugin_name : public threadloop { public: /* After the constructor, C++ permits a list of member-constructors. I use uniform initialization (curly-braces) [1] instead of parens to avoid ambiguity [2]. I put the comma at the start of the line, so that lines can be copied around or deleted freely (except for the first). [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization [2]: https://en.wikipedia.org/wiki/Most_vexing_parse */ plugin_name(phonebook* pb) // find the switchboard in phonebook : sb{pb->lookup_impl<switchboard>()} // create a handle to a topic in switchboard for subscribing , topic1{sb->subscribe_latest<topic1_type>(\"topic1\")} // create a handle to a topic in switchboard for publishing , topic2{sb->publish<topic2_type>(\"topic2\")} { // Read topic 1 topic1_type* event1 = topic1.get_latest_ro(); // Write to topic 2 topic2_type* event2 = new topic2_type; topic2.put(event2); // Read topic 3 synchronously sb->schedule<topic3_type>(\"topic3\", [&](const topic3_type *event3) { /* This is a [lambda expression][1] [1]: https://en.cppreference.com/w/cpp/language/lambda */ std::cout << \"Got a new event on topic3: \" << event3 << std::endl; }); } private: switchboard* pb std::unique_ptr<reader_latest<topic1_type>> topic1; std::unique_ptr<writer<topic2>> topic2; };","title":"Writing your plugin"}]}