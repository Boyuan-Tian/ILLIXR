{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ILLIXR ILLIXR (pronounced like elixir) is an open-source Extended Reality (XR) benchmark suite. It contains several core state-of-the-art components of a generic XR pipeline, components that are required in most, if not all, XR applications. Mosst of the functionality is implemented as plugins in our runtime. Documentation Yes! Publications Get In Touch Whether you are a computer architect, a systems person, an XR application developer, or just anyone interested in XR, we would love to hear your feedback on ILLIXR! ILLIXR is a living benchmark suite and we would like to both refine existing components and add new ones. We believe ILLIXR has the opportunity to drive future computer architecture and systems research for XR, and can benefit from contributions from other researchers and organizations. If you would like to be a part of this effort, please contact us at illixr at cs dot illinois dot edu","title":"ILLIXR"},{"location":"#illixr","text":"ILLIXR (pronounced like elixir) is an open-source Extended Reality (XR) benchmark suite. It contains several core state-of-the-art components of a generic XR pipeline, components that are required in most, if not all, XR applications. Mosst of the functionality is implemented as plugins in our runtime.","title":"ILLIXR"},{"location":"#documentation","text":"Yes!","title":"Documentation"},{"location":"#publications","text":"","title":"Publications"},{"location":"#get-in-touch","text":"Whether you are a computer architect, a systems person, an XR application developer, or just anyone interested in XR, we would love to hear your feedback on ILLIXR! ILLIXR is a living benchmark suite and we would like to both refine existing components and add new ones. We believe ILLIXR has the opportunity to drive future computer architecture and systems research for XR, and can benefit from contributions from other researchers and organizations. If you would like to be a part of this effort, please contact us at illixr at cs dot illinois dot edu","title":"Get In Touch"},{"location":"audio_pipeline/","text":"Audio pipeline audio_pipeline subscribes to the most recent pose, does ambisonics encoding, spatial zoom and rotation according to the pose, ambisonics decoding and binauralization to output a block of 1024 sound samples each time at 48000 Hz sample rate. Therefore it has a 21.3ms period to process each block. If it misses a deadline, it keeps doing its current work for the next deadline. Currently this component is for profiling purpose only. It does read a pose from illixr, but the pose is not used by spaitial zoom and rotation. Performance-wise, the audio pipeline is input invariant.","title":"Audio pipeline"},{"location":"audio_pipeline/#audio-pipeline","text":"audio_pipeline subscribes to the most recent pose, does ambisonics encoding, spatial zoom and rotation according to the pose, ambisonics decoding and binauralization to output a block of 1024 sound samples each time at 48000 Hz sample rate. Therefore it has a 21.3ms period to process each block. If it misses a deadline, it keeps doing its current work for the next deadline. Currently this component is for profiling purpose only. It does read a pose from illixr, but the pose is not used by spaitial zoom and rotation. Performance-wise, the audio pipeline is input invariant.","title":"Audio pipeline"},{"location":"building_ILLIXR/","text":"Building ILLIXR Basic usage From the project root, make run.dbg -j$(nproc) will build the ILLIXR runtime standalone, the ILLIXR plugins, and run it for you. make run.opt -j$(nproc) , is the same but with optimizations on and debug off. Adding a new plugin (common case) In the common case, one need only define a Makefile with the line include common/common.mk and symlink common ( ln -s ../common common ). This provides the necessary targets and uses the compiler $(CXX) , which is defined in Make based on the OS and environment variables. It compiles plugin.cpp and any other *.cpp files into the plugin. It will invoke a recompile the target any time any *.hpp or *.cpp file changes. It compiles with C++17. You can change this in your plugin by defining STDCXX = ... before the include . This change will not affect other plugins; just yours. Libraries can be added by appending to LDFLAGS and CFLAGS , for example LDFLAGS := $(LDFLAGS) $(shell pkg-config --ldflags eigen3) CFLAGS := $(CFLAGS) $(shell pkg-config --cflags eigen3) See the source for the exact flags. Inserted the name of your directory into the component -list in the root Makefile . Adding a plugin (general case) Each plugin can have a completely independent build system, as long as: - It defines a Makefile with targets for plugin.dbg.so , plugin.opt.so , and clean . Inside this Makefile , one can defer to another build system. It's compiler maintains ABI compatibility with the compilers used in every other plugin. Using the same version of Clang or GCC on the same architecture is sufficient for this. It's name is inserted in the root Makefile , in the plugins list. Philosophy Each plugin should not have to know or care how the others are compiled. In the future, they may even be distributed separately, just as SOs. Therefore, each plugin needs its own build system. Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins should be extremely easy. It should be easy to build in parallel. Always rebuild every time, so the binary is always \"fresh\". This is a great convenience when experimenting. However, this implies that rebuilding must be fast when not much has changed. Make is the de facto standard for building C/C++ programs. GNU Make, reucrsive make, and the makefile language begets no shortage of problems [ 1 , 2 , 3 , 4 , 5 ], but I chose Make for its tradeoff of between simplicity and functionality. What it lacks in functionality (compared to CMake, Ninja, scons, Bazel, Meson) it makes up for in simplicity. It's still the build system in which it is the easiest to invoke arbitrary commands in shell and the easiest to have a common.mk included in each plugin. This decision to use Make should be revisited, when this project outgrows its ability, but for now, Make remains, in my judgement, the best tool for the job .","title":"Building ILLIXR"},{"location":"building_ILLIXR/#building-illixr","text":"","title":"Building ILLIXR"},{"location":"building_ILLIXR/#basic-usage","text":"From the project root, make run.dbg -j$(nproc) will build the ILLIXR runtime standalone, the ILLIXR plugins, and run it for you. make run.opt -j$(nproc) , is the same but with optimizations on and debug off.","title":"Basic usage"},{"location":"building_ILLIXR/#adding-a-new-plugin-common-case","text":"In the common case, one need only define a Makefile with the line include common/common.mk and symlink common ( ln -s ../common common ). This provides the necessary targets and uses the compiler $(CXX) , which is defined in Make based on the OS and environment variables. It compiles plugin.cpp and any other *.cpp files into the plugin. It will invoke a recompile the target any time any *.hpp or *.cpp file changes. It compiles with C++17. You can change this in your plugin by defining STDCXX = ... before the include . This change will not affect other plugins; just yours. Libraries can be added by appending to LDFLAGS and CFLAGS , for example LDFLAGS := $(LDFLAGS) $(shell pkg-config --ldflags eigen3) CFLAGS := $(CFLAGS) $(shell pkg-config --cflags eigen3) See the source for the exact flags. Inserted the name of your directory into the component -list in the root Makefile .","title":"Adding a new plugin (common case)"},{"location":"building_ILLIXR/#adding-a-plugin-general-case","text":"Each plugin can have a completely independent build system, as long as: - It defines a Makefile with targets for plugin.dbg.so , plugin.opt.so , and clean . Inside this Makefile , one can defer to another build system. It's compiler maintains ABI compatibility with the compilers used in every other plugin. Using the same version of Clang or GCC on the same architecture is sufficient for this. It's name is inserted in the root Makefile , in the plugins list.","title":"Adding a plugin (general case)"},{"location":"building_ILLIXR/#philosophy","text":"Each plugin should not have to know or care how the others are compiled. In the future, they may even be distributed separately, just as SOs. Therefore, each plugin needs its own build system. Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins should be extremely easy. It should be easy to build in parallel. Always rebuild every time, so the binary is always \"fresh\". This is a great convenience when experimenting. However, this implies that rebuilding must be fast when not much has changed. Make is the de facto standard for building C/C++ programs. GNU Make, reucrsive make, and the makefile language begets no shortage of problems [ 1 , 2 , 3 , 4 , 5 ], but I chose Make for its tradeoff of between simplicity and functionality. What it lacks in functionality (compared to CMake, Ninja, scons, Bazel, Meson) it makes up for in simplicity. It's still the build system in which it is the easiest to invoke arbitrary commands in shell and the easiest to have a common.mk included in each plugin. This decision to use Make should be revisited, when this project outgrows its ability, but for now, Make remains, in my judgement, the best tool for the job .","title":"Philosophy"},{"location":"default_plugins/","text":"Default Plugins offline_imu_cam : Reads IMU data and images from files on disk, emulating a real sensor on the headset (feeds input measurements with timing similar to an actual IMU). ground_truth_slam : Reads the ground-truth from the same dataset to compare our output against (uses timing from offline_imu_cam ). open_vins : Runs OpenVINS on the input, and outputs a the headset's pose. In practice, this publishes a fairly slow pose, so pose prediction is required to infer a fast pose. We do not yet have pose prediction, so we say open_vins also publishes a fast pose. gldemo : Renders a static scene (into left and right eyebuffers) given the pose from open_vins . timewarp_gl : Asynchronous reprojection of the eyebuffers. debugview : Renders a frame for debug information. audio : TODO: this. By default this is disabled, since it requires an NVIDIA GPU. hologram : TODO: this. By default this is disabled, since it requires an NVIDIA GPU. Below this point, I will use Switchboard terminology. Read the API documentation on switchboard for definitions. In the above figure, rectangles are plugins, cylinders are topics (the graph is bipartitioned between these two gorups). Solid arrows from plugins to topics represent publishing. Solid arrows from topics to plugins represent synchronous reading. They take some action for every event which gets published on the topic. Solid arrows from topics to plugins represent asynchronous reading. They need to know just the latest event on their topic. Imagine the topic as a trough filing with events from its publisher, being drained by its synchronous readers (AKA subscribers), while asynchronous readres just skim from the top. See Writing Your Plugin to extend ILLIXR.","title":"Default Plugins"},{"location":"default_plugins/#default-plugins","text":"offline_imu_cam : Reads IMU data and images from files on disk, emulating a real sensor on the headset (feeds input measurements with timing similar to an actual IMU). ground_truth_slam : Reads the ground-truth from the same dataset to compare our output against (uses timing from offline_imu_cam ). open_vins : Runs OpenVINS on the input, and outputs a the headset's pose. In practice, this publishes a fairly slow pose, so pose prediction is required to infer a fast pose. We do not yet have pose prediction, so we say open_vins also publishes a fast pose. gldemo : Renders a static scene (into left and right eyebuffers) given the pose from open_vins . timewarp_gl : Asynchronous reprojection of the eyebuffers. debugview : Renders a frame for debug information. audio : TODO: this. By default this is disabled, since it requires an NVIDIA GPU. hologram : TODO: this. By default this is disabled, since it requires an NVIDIA GPU. Below this point, I will use Switchboard terminology. Read the API documentation on switchboard for definitions. In the above figure, rectangles are plugins, cylinders are topics (the graph is bipartitioned between these two gorups). Solid arrows from plugins to topics represent publishing. Solid arrows from topics to plugins represent synchronous reading. They take some action for every event which gets published on the topic. Solid arrows from topics to plugins represent asynchronous reading. They need to know just the latest event on their topic. Imagine the topic as a trough filing with events from its publisher, being drained by its synchronous readers (AKA subscribers), while asynchronous readres just skim from the top. See Writing Your Plugin to extend ILLIXR.","title":"Default Plugins"},{"location":"design/","text":"Design Spindle Switchboard Threadsafety","title":"Design"},{"location":"design/#design","text":"","title":"Design"},{"location":"design/#spindle","text":"","title":"Spindle"},{"location":"design/#switchboard","text":"","title":"Switchboard"},{"location":"design/#threadsafety","text":"","title":"Threadsafety"},{"location":"getting_started/","text":"Getting Started ILLIXR standalone The ILLIXR runtime can be built \"standalone\", to run without Monado. This mode does not support OpenXR, but it is faster for development. These instructions have been tested with Ubuntu 18.10. Clone the repository. git clone --recursive https://github.com/charmoniumQ/illixr-prototype # TODO: update this link when we move repositories Update the submodules. Submodules are git repositories inside a git repository that need to be pulled down separately. git submodule update --init --recursive Install dependencies. This script installs some Ubuntu/Debian packages and builds a specific version of OpenCV from source. ./install_deps.sh Build and run ILLIXR standalone. make run.dbg ILLIXR with Monado (supports OpenXR) Monado only supports Ubuntu 18.10, because of a low-level driver issue. Clone and build ILLIXR (same steps as standalone, except the make target is all.dbg.so ). git clone --recursive https://github.com/charmoniumQ/illixr-prototype git submodule update --init --recursive ./install_deps.sh make all.dbg.so Clone and build Monado. git clone https://github.com/ILLIXR/monado_integration.git cd monado_integration mkdir build && cd build cmake .. -DBUILD_WITH_LIBUDEV=0 -DBUILD_WITH_LIBUVC=0 -DBUILD_WITH_LIBUSB=0 -DBUILD_WITH_LIBUDEV=0 -DBUILD_WITH_NS=0 -DBUILD_WITH_PSMV=0 -DBUILD_WITH_PSVR=0 -DBUILD_WITH_OPENHMD=0 -DBUILD_WITH_VIVE=0 -DILLIXR_PATH=../../ILLIXR -G \"Unix Makefiles\" # replace ../ILLIXR with the path to ILLIXR make -j$(nproc) Clone and build our application example. git clone https://gitlab.freedesktop.org/monado/demos/openxr-simple-example cd openxr-simple-example mkdir build && cd build cmake .. make -j$(nproc) Set environment variables and run. export XR_RUNTIME_JSON=../monado_integration/build/openxr_monado-dev.json # replace ../monado_integration with the path to the previous repo export ILLIXR_PATH=../ILLIXR/runtime/plugin.dbg.so export ILLIXR_COMP=../ILLIXR/ground_truth_slam/plugin.dbg.so:../ILLIXR/offline_imu_cam/plugin.dbg.so:../ILLIXR/open_vins/plugin.dbg.so:../ILLIXR/pose_prediction/plugin.dbg.so:../ILLIXR/timewarp_gl/plugin.dbg.so:../ILLIXR/debugview/plugin.dbg.so:../ILLIXR/audio_pipeline/plugin.dbg.so # replace ../ILLIXR with the path to ILLIXR Next steps The source code is divided into the following directories: - runtime : create a runnable binary that loads every plugin. * This contains Spindle, which is responsible for loading plugins. common : resources one might use in each plugin. Most plugins symlink this directory into theirs. Contains the interface for Switchboard, which maintains event-streams (implementation is in runtime ). Contains the interface for Phonebook, which is a service-directory (implementation is in runtime ). a directory for each plugin. Almost all of the XR functionality is implemented in plugins. See Default Components for more details. Try browsing the source of plugins. If you edit any of the source files, this make commend will detect and rebuild the respective binary. If you want to add your own, see Writing Your Plugin .","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#illixr-standalone","text":"The ILLIXR runtime can be built \"standalone\", to run without Monado. This mode does not support OpenXR, but it is faster for development. These instructions have been tested with Ubuntu 18.10. Clone the repository. git clone --recursive https://github.com/charmoniumQ/illixr-prototype # TODO: update this link when we move repositories Update the submodules. Submodules are git repositories inside a git repository that need to be pulled down separately. git submodule update --init --recursive Install dependencies. This script installs some Ubuntu/Debian packages and builds a specific version of OpenCV from source. ./install_deps.sh Build and run ILLIXR standalone. make run.dbg","title":"ILLIXR standalone"},{"location":"getting_started/#illixr-with-monado-supports-openxr","text":"Monado only supports Ubuntu 18.10, because of a low-level driver issue. Clone and build ILLIXR (same steps as standalone, except the make target is all.dbg.so ). git clone --recursive https://github.com/charmoniumQ/illixr-prototype git submodule update --init --recursive ./install_deps.sh make all.dbg.so Clone and build Monado. git clone https://github.com/ILLIXR/monado_integration.git cd monado_integration mkdir build && cd build cmake .. -DBUILD_WITH_LIBUDEV=0 -DBUILD_WITH_LIBUVC=0 -DBUILD_WITH_LIBUSB=0 -DBUILD_WITH_LIBUDEV=0 -DBUILD_WITH_NS=0 -DBUILD_WITH_PSMV=0 -DBUILD_WITH_PSVR=0 -DBUILD_WITH_OPENHMD=0 -DBUILD_WITH_VIVE=0 -DILLIXR_PATH=../../ILLIXR -G \"Unix Makefiles\" # replace ../ILLIXR with the path to ILLIXR make -j$(nproc) Clone and build our application example. git clone https://gitlab.freedesktop.org/monado/demos/openxr-simple-example cd openxr-simple-example mkdir build && cd build cmake .. make -j$(nproc) Set environment variables and run. export XR_RUNTIME_JSON=../monado_integration/build/openxr_monado-dev.json # replace ../monado_integration with the path to the previous repo export ILLIXR_PATH=../ILLIXR/runtime/plugin.dbg.so export ILLIXR_COMP=../ILLIXR/ground_truth_slam/plugin.dbg.so:../ILLIXR/offline_imu_cam/plugin.dbg.so:../ILLIXR/open_vins/plugin.dbg.so:../ILLIXR/pose_prediction/plugin.dbg.so:../ILLIXR/timewarp_gl/plugin.dbg.so:../ILLIXR/debugview/plugin.dbg.so:../ILLIXR/audio_pipeline/plugin.dbg.so # replace ../ILLIXR with the path to ILLIXR","title":"ILLIXR with Monado (supports OpenXR)"},{"location":"getting_started/#next-steps","text":"The source code is divided into the following directories: - runtime : create a runnable binary that loads every plugin. * This contains Spindle, which is responsible for loading plugins. common : resources one might use in each plugin. Most plugins symlink this directory into theirs. Contains the interface for Switchboard, which maintains event-streams (implementation is in runtime ). Contains the interface for Phonebook, which is a service-directory (implementation is in runtime ). a directory for each plugin. Almost all of the XR functionality is implemented in plugins. See Default Components for more details. Try browsing the source of plugins. If you edit any of the source files, this make commend will detect and rebuild the respective binary. If you want to add your own, see Writing Your Plugin .","title":"Next steps"},{"location":"hologram/","text":"Hologram hologram , computational holography, subscribes to a timewarp_gl output signal indicating a timewarped frame, which means hologram should start processing. Hologram takes depth buffer of the frame to calculate a Spatial Light Modulator input. For more details of hologram, please refer to our paper. Since we do not have an accurate prediction of vsync, hologram process is one frame delayed. Currently this component is for profiling purpose only. Performance-wise, hologram is input invariant. Current illixr and monado do not support depth buffer from user application. Algorithms to calculate depth spots from depth buffer is also missing.","title":"Hologram"},{"location":"hologram/#hologram","text":"hologram , computational holography, subscribes to a timewarp_gl output signal indicating a timewarped frame, which means hologram should start processing. Hologram takes depth buffer of the frame to calculate a Spatial Light Modulator input. For more details of hologram, please refer to our paper. Since we do not have an accurate prediction of vsync, hologram process is one frame delayed. Currently this component is for profiling purpose only. Performance-wise, hologram is input invariant. Current illixr and monado do not support depth buffer from user application. Algorithms to calculate depth spots from depth buffer is also missing.","title":"Hologram"},{"location":"monado_illixr_runtime_overview/","text":"Monado-Illixr Runtime Overview When running standalone without Monado, the Illixr runtime is the entry-point. Phonebook and switchboard are initialized and plugins are loaded, among which is the gldemo app. When running from Monado, however, as mandated by OpenXR specifications, the application is the entry point. As a result, the Illixr runtime system is loaded at a later point as a shared library. This article documents the changes to the Illixr runtime when an OpenXR application is used. 1. App launches and brings up Monado As specified by OpenXR, the OpenXR application initializes the OpenXR runtime by reading a configuration JSON file pointed to by an environment variable and loads the OpenXR runtime, which is Monado in this case, as a shared library into its address space. Consult the OpenXR specifications and the OpenXR-SDK from Khronous Group for more details. 2. Monado probes HMD devices and Illixr Initializes During initialization, Monado asks all drivers to probe for and initialize HMDs and controllers, internally known as xdev s. We have an Illixr driver, which will always respond to Monado with one discovered HMD that will be used to capture OpenXR queries and events from Monado's state tracker. The Illixr driver obtains the path to the Illixr runtime so file and a list of plugins from environment variables. After probing is finished, the application will start to create an OpenXR session. At some point in this process, the application will send its rendering context to the runtime, which we capture and send to the Illixr driver. At this moment, all necessary data is ready and Illixr will be launched. 3. Illixr Runtime Launch When used with Monado, the Illixr runtime is compiled into a shared library instead of an executable. The library exports its two major functionalities: initializing switchboard and phonebook, and load plugins. The drivers starts to load the runtime by loading the shared library into the current (the app's) address space and calls the switchboard and phonebook initialization. Then, it calls the plugin loading for each Illixr plugin (except gldemo, which is replaced by the OpenXR app). Finally, it calls a special plugin loading which takes a function address instead of a file path to load a translation plugin into Illixr as the application. The translation plugin will be in the next section. Each plugin should either not block or start its own thread, so the driver will be able to reacquire control and return to Monado and the app shortly. 4. The translation plugin When the app and all Illixr plugins are up and running, the translation plugin handles the connection between Monado and Illixr. It might be confusing to see that this plugin is part of the Illixr driver which is part of Monado while at the same time also part of Illixr as a plugin. But Monado and Illixr are running in different threads in the same address space. The translation plugin is the intersection of these two parallel systems serving as a bridge between the two. The translation plugin handles two types of events at the moment: pose requests and frame submissions. From the view of Monado, it is the destination of all requests: from the application, to Monado's state trackers, to the xdev interface who is responsible for servicing the request. From the view of Illixr, it behaves the same as the gldemo app: reading pose and submitting frames. For implementation details regarding the representation of poses and frames in Monado and in Illixr, please see Monado Integration Dataflow.","title":"Monado-Illixr Runtime Overview"},{"location":"monado_illixr_runtime_overview/#monado-illixr-runtime-overview","text":"When running standalone without Monado, the Illixr runtime is the entry-point. Phonebook and switchboard are initialized and plugins are loaded, among which is the gldemo app. When running from Monado, however, as mandated by OpenXR specifications, the application is the entry point. As a result, the Illixr runtime system is loaded at a later point as a shared library. This article documents the changes to the Illixr runtime when an OpenXR application is used.","title":"Monado-Illixr Runtime Overview"},{"location":"monado_illixr_runtime_overview/#1-app-launches-and-brings-up-monado","text":"As specified by OpenXR, the OpenXR application initializes the OpenXR runtime by reading a configuration JSON file pointed to by an environment variable and loads the OpenXR runtime, which is Monado in this case, as a shared library into its address space. Consult the OpenXR specifications and the OpenXR-SDK from Khronous Group for more details.","title":"1. App launches and brings up Monado"},{"location":"monado_illixr_runtime_overview/#2-monado-probes-hmd-devices-and-illixr-initializes","text":"During initialization, Monado asks all drivers to probe for and initialize HMDs and controllers, internally known as xdev s. We have an Illixr driver, which will always respond to Monado with one discovered HMD that will be used to capture OpenXR queries and events from Monado's state tracker. The Illixr driver obtains the path to the Illixr runtime so file and a list of plugins from environment variables. After probing is finished, the application will start to create an OpenXR session. At some point in this process, the application will send its rendering context to the runtime, which we capture and send to the Illixr driver. At this moment, all necessary data is ready and Illixr will be launched.","title":"2.  Monado probes HMD devices and Illixr Initializes"},{"location":"monado_illixr_runtime_overview/#3-illixr-runtime-launch","text":"When used with Monado, the Illixr runtime is compiled into a shared library instead of an executable. The library exports its two major functionalities: initializing switchboard and phonebook, and load plugins. The drivers starts to load the runtime by loading the shared library into the current (the app's) address space and calls the switchboard and phonebook initialization. Then, it calls the plugin loading for each Illixr plugin (except gldemo, which is replaced by the OpenXR app). Finally, it calls a special plugin loading which takes a function address instead of a file path to load a translation plugin into Illixr as the application. The translation plugin will be in the next section. Each plugin should either not block or start its own thread, so the driver will be able to reacquire control and return to Monado and the app shortly.","title":"3. Illixr Runtime Launch"},{"location":"monado_illixr_runtime_overview/#4-the-translation-plugin","text":"When the app and all Illixr plugins are up and running, the translation plugin handles the connection between Monado and Illixr. It might be confusing to see that this plugin is part of the Illixr driver which is part of Monado while at the same time also part of Illixr as a plugin. But Monado and Illixr are running in different threads in the same address space. The translation plugin is the intersection of these two parallel systems serving as a bridge between the two. The translation plugin handles two types of events at the moment: pose requests and frame submissions. From the view of Monado, it is the destination of all requests: from the application, to Monado's state trackers, to the xdev interface who is responsible for servicing the request. From the view of Illixr, it behaves the same as the gldemo app: reading pose and submitting frames. For implementation details regarding the representation of poses and frames in Monado and in Illixr, please see Monado Integration Dataflow.","title":"4. The translation plugin"},{"location":"monado_integration_dataflow/","text":"Monado integration dataflow The integration for monado in terms of dataflow can be divided into two parts, getting pose from illixr, and sending user rendered frame to illixr. In monado, illixr looks like an HMD for monado, while in illixr, monado looks like a user application as gldemo . After illixr is initialized from monado, and monado is registered as a plugin for illixr, most recent pose information is easy to get from switchboard. The compositor side of monado integration with illixr is done in more subtle way. Original monado compositor mostly does distortion correction and aberration correction in a vulkan back-end compositor. It also has two client compositor, one for opengl app, the other for vulkan app, which pass frame data to the back-end compositor. Illixr integration intercepts the frame at gl client compositor and sends it to switchboard of illixr, which is then used by timewarp_gl component. In order to get a opengl frame and use it without copying pixels, illixr needs to get the user application gl context. It is done at OpenXR session creation time, where illixr is initialized. Note that logically illixr is initialized during OpenXR instance creation, or running at the background all the time. But, since illixr only supports single session at this time, and requires a user application gl context upon initialization, illixr is initialized at session creation time. Current illixr integration for monado is a temporary solution and has some downsides because of the progress from both monado and illixr. 1. It does not use the pose that user application declares to use at rendering (OpenXR specification) because of monado internal interfaces. The pose difference used by timewarp comes from the last pose query call. 2. It cannot submit frame with depth buffer. 3. The pose from illixr does not vary according to the OpenXR space. It is a raw pose data from slam algorithms. 4. No controller action support at all. 5. It only supports gl user applications. 6. User application cannot acquire more than one swapchain image (for each eye) in one frame. 7. Illixr is initialized during session creation time.","title":"Monado integration dataflow"},{"location":"monado_integration_dataflow/#monado-integration-dataflow","text":"The integration for monado in terms of dataflow can be divided into two parts, getting pose from illixr, and sending user rendered frame to illixr. In monado, illixr looks like an HMD for monado, while in illixr, monado looks like a user application as gldemo . After illixr is initialized from monado, and monado is registered as a plugin for illixr, most recent pose information is easy to get from switchboard. The compositor side of monado integration with illixr is done in more subtle way. Original monado compositor mostly does distortion correction and aberration correction in a vulkan back-end compositor. It also has two client compositor, one for opengl app, the other for vulkan app, which pass frame data to the back-end compositor. Illixr integration intercepts the frame at gl client compositor and sends it to switchboard of illixr, which is then used by timewarp_gl component. In order to get a opengl frame and use it without copying pixels, illixr needs to get the user application gl context. It is done at OpenXR session creation time, where illixr is initialized. Note that logically illixr is initialized during OpenXR instance creation, or running at the background all the time. But, since illixr only supports single session at this time, and requires a user application gl context upon initialization, illixr is initialized at session creation time. Current illixr integration for monado is a temporary solution and has some downsides because of the progress from both monado and illixr. 1. It does not use the pose that user application declares to use at rendering (OpenXR specification) because of monado internal interfaces. The pose difference used by timewarp comes from the last pose query call. 2. It cannot submit frame with depth buffer. 3. The pose from illixr does not vary according to the OpenXR space. It is a raw pose data from slam algorithms. 4. No controller action support at all. 5. It only supports gl user applications. 6. User application cannot acquire more than one swapchain image (for each eye) in one frame. 7. Illixr is initialized during session creation time.","title":"Monado integration dataflow"},{"location":"visualizer_logger/","text":"Visualizer & Logger There is a utility header file common/logger.hpp , which is a logger for recording process starting and ending time, with respect to the component initialization time. Currently, only audio_pipeline and hologram use this logger. Please create a log directory in your running binary directory to let those log files correctly appear. log/visualizer.py is a script to create visual timeline according to the log files in the same directory. It is not convenient to use or precisely correct right now.","title":"Visualizer logger"},{"location":"visualizer_logger/#visualizer-logger","text":"There is a utility header file common/logger.hpp , which is a logger for recording process starting and ending time, with respect to the component initialization time. Currently, only audio_pipeline and hologram use this logger. Please create a log directory in your running binary directory to let those log files correctly appear. log/visualizer.py is a script to create visual timeline according to the log files in the same directory. It is not convenient to use or precisely correct right now.","title":"Visualizer &amp; Logger"},{"location":"writing_your_plugin/","text":"Writing your plugin With this, you can extend ILLIXR for your own purposes. You can also replace any existing functionality this way. We suggest making a subdirectory in the ILLIXR repo, but one could make it anywhere. Add this directory to plugins in ILLIXR's root Makefile . The order in this list determines the order of initialization in the program. phonebook , for example, is order-sensitive. In your plugin directory, we suggest symlinking common ( ln -s ../common common ). Create a Makefile with the following contents. See Building ILLIXR for more details and alternative setups. include common.mk You must decide if your plugin should inherit the standardized threadloop or plugin . If your plugin just needs to run one computation repeatedly, then your plugin class should extend threadloop . If you need custom concurrency (more complicated than a loop), triggered concurrency (by events fired in other plugins), or no concurrency then your plugin class should extend plugin . Write a file called plugin.cpp with this body, replacing every instance of plugin_name : #include \"common/phonebook.hpp\" #include \"common/plugin.hpp\" #include \"common/threadloop.hpp\" using ILLIXR; // Inherit from `plugin` if you don't need the threadloop class plugin_name : public threadloop { public: plugin_name(phonebook* pb) { } virtual void start() override { } virtual ~plugin_name() override { } }; // This line makes the plugin importable by Spindle PLUGIN_MAIN(plugin_name); At this point, you should be able to go to the ILLIXR root and make dbg . If you edit a source file and then make dbg , it should trigger a rebuild of your plugin. This is all that is required to be a plugin which can be loaded by Spindle in the ILLIXR runtime. Reading and writing from Phonebook and Switchboard optional, but nearly every plugin does it. See default_plugins.md for more details. First, we can query the phonebook to get various services including switchboard . Then we query switchboard for event-streams (topics). We will read topic1 , write to topic2 , and schedule computation on topic 3 . See the API documentation for phonebook and switchboard for more details. #include \"common/phonebook.hpp\" #include \"common/plugin.hpp\" #include \"common/threadloop.hpp\" /* When datatypes have to be common across plugins (e.g. a phonebook service or switchboard topic), they are defined in this header, which is accessible to all plugins. */ #include \"common/data_formath.hpp\" class plugin_name : public threadloop { public: /* After the constructor, C++ permits a list of member-constructors. I use uniform initialization (curly-braces) [1] instead of parens to avoid ambiguity [2]. I put the comma at the start of the line, so that lines can be copied around or deleted freely (except for the first). [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization [2]: https://en.wikipedia.org/wiki/Most_vexing_parse */ plugin_name(phonebook* pb) // find the switchboard in phonebook : sb{pb->lookup_impl<switchboard>()} // create a handle to a topic in switchboard for subscribing , topic1{sb->subscribe_latest<topic1_type>(\"topic1\")} // create a handle to a topic in switchboard for publishing , topic2{sb->publish<topic2_type>(\"topic2\")} { // Read topic 1 topic1_type* event1 = topic1.get_latest_ro(); // Write to topic 2 topic2_type* event2 = new topic2_type; topic2.put(event2); // Read topic 3 synchronously sb->schedule<topic3_type>(\"topic3\", [&](const topic3_type *event3) { /* This is a [lambda expression][1] [1]: https://en.cppreference.com/w/cpp/language/lambda */ std::cout << \"Got a new event on topic3: \" << event3 << std::endl; }); } private: switchboard* pb std::unique_ptr<reader_latest<topic1_type>> topic1; std::unique_ptr<writer<topic2>> topic2; };","title":"Writing Your Plugin"},{"location":"writing_your_plugin/#writing-your-plugin","text":"With this, you can extend ILLIXR for your own purposes. You can also replace any existing functionality this way. We suggest making a subdirectory in the ILLIXR repo, but one could make it anywhere. Add this directory to plugins in ILLIXR's root Makefile . The order in this list determines the order of initialization in the program. phonebook , for example, is order-sensitive. In your plugin directory, we suggest symlinking common ( ln -s ../common common ). Create a Makefile with the following contents. See Building ILLIXR for more details and alternative setups. include common.mk You must decide if your plugin should inherit the standardized threadloop or plugin . If your plugin just needs to run one computation repeatedly, then your plugin class should extend threadloop . If you need custom concurrency (more complicated than a loop), triggered concurrency (by events fired in other plugins), or no concurrency then your plugin class should extend plugin . Write a file called plugin.cpp with this body, replacing every instance of plugin_name : #include \"common/phonebook.hpp\" #include \"common/plugin.hpp\" #include \"common/threadloop.hpp\" using ILLIXR; // Inherit from `plugin` if you don't need the threadloop class plugin_name : public threadloop { public: plugin_name(phonebook* pb) { } virtual void start() override { } virtual ~plugin_name() override { } }; // This line makes the plugin importable by Spindle PLUGIN_MAIN(plugin_name); At this point, you should be able to go to the ILLIXR root and make dbg . If you edit a source file and then make dbg , it should trigger a rebuild of your plugin. This is all that is required to be a plugin which can be loaded by Spindle in the ILLIXR runtime. Reading and writing from Phonebook and Switchboard optional, but nearly every plugin does it. See default_plugins.md for more details. First, we can query the phonebook to get various services including switchboard . Then we query switchboard for event-streams (topics). We will read topic1 , write to topic2 , and schedule computation on topic 3 . See the API documentation for phonebook and switchboard for more details. #include \"common/phonebook.hpp\" #include \"common/plugin.hpp\" #include \"common/threadloop.hpp\" /* When datatypes have to be common across plugins (e.g. a phonebook service or switchboard topic), they are defined in this header, which is accessible to all plugins. */ #include \"common/data_formath.hpp\" class plugin_name : public threadloop { public: /* After the constructor, C++ permits a list of member-constructors. I use uniform initialization (curly-braces) [1] instead of parens to avoid ambiguity [2]. I put the comma at the start of the line, so that lines can be copied around or deleted freely (except for the first). [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization [2]: https://en.wikipedia.org/wiki/Most_vexing_parse */ plugin_name(phonebook* pb) // find the switchboard in phonebook : sb{pb->lookup_impl<switchboard>()} // create a handle to a topic in switchboard for subscribing , topic1{sb->subscribe_latest<topic1_type>(\"topic1\")} // create a handle to a topic in switchboard for publishing , topic2{sb->publish<topic2_type>(\"topic2\")} { // Read topic 1 topic1_type* event1 = topic1.get_latest_ro(); // Write to topic 2 topic2_type* event2 = new topic2_type; topic2.put(event2); // Read topic 3 synchronously sb->schedule<topic3_type>(\"topic3\", [&](const topic3_type *event3) { /* This is a [lambda expression][1] [1]: https://en.cppreference.com/w/cpp/language/lambda */ std::cout << \"Got a new event on topic3: \" << event3 << std::endl; }); } private: switchboard* pb std::unique_ptr<reader_latest<topic1_type>> topic1; std::unique_ptr<writer<topic2>> topic2; };","title":"Writing your plugin"}]}