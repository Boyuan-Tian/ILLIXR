{
    "docs": [
        {
            "location": "/",
            "text": "ILLIXR\n\n\n\n\nIllinois Extended Reality testbed or ILLIXR (pronounced like elixir) is the first open-source full-system Extended Reality (XR) testbed. It contains standalone state-of-the-art components representative of a generic XR workflow, as well as a runtime framework that integrates these components into an XR system. ILLIXR's runtime integration framework is modular, extensible, and \nOpenXR\n-compatible.\n\n\nWe use the term \ncomponents\n and not \nkernels\n or \ncomputations\n because each component of ILLIXR is an entire application in itself, and consists of many kernels and computations. At the moment, ILLIXR contains the following state-of-the-art components, all of which can be found packaged together in the \nv1-latest release\n of ILLIXR.\n\n\n\n\nSimultaneous Localization and Mapping\n\n\nScene reconstruction\n\n\nEye tracking\n\n\nAmbisonic encoding\n\n\nAmbisonic manipulation and binauralization\n\n\nLens distortion correction\n\n\nChromatic aberration correction\n\n\nTime warp\n\n\nComputational holography for adaptive multi-focal displays\n\n\n\n\nWe plan on adding more components (e.g., graphics and multiple versions for individual components) and extending the runtime in the future. Our goal is not to create a commercial quality XR product for current hardware. Instead, the goal for ILLIXR is to advance computer architecture, systems, and hardware-software co-design research for XR by making available a full system and key state-of-the-art components of both modern and future XR applications.\n\n\nMany of the current components of ILLIXR were developed by domain experts and obtained from publicly available repositories. They were modified for one or more of the following reasons: fixing compilation, adding features, or removing extraneous code or dependencies. Each component not developed by us is available as a forked github repository for proper attribution to its authors.\n\n\nDetailed descriptions of each component and our runtime, including performance and energy profiles, can be found in our \npaper\n.\n\n\nPublications\n\n\nWe request that you cite our following paper (new version coming soon) when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published.\n\n\n@misc{HuzaifaDesai2020,\n    title={Exploring Extended Reality with ILLIXR: A new Playground for Architecture Research},\n    author={Muhammad Huzaifa and Rishi Desai and Xutao Jiang and Joseph Ravichandran and Finn Sinclair and Sarita V. Adve},\n    year={2020},\n    eprint={2004.04643},\n    primaryClass={cs.DC}\n}\n\n\n\n\nGetting Started and Documentation\n\n\nFor more information, see our \ngetting started page\n.\n\n\nAcknowledgements\n\n\nMuhammad Huzaifa led the development of ILLIXR in \nSarita Adve\u2019s research group\n at the University of Illinois at Urbana-Champaign. Other major contributors include Rishi Desai, Samuel Grayson, Xutao Jiang, Ying Jing, Jae Lee, Fang Lu, Joseph Ravichandran, Finn Sinclair, Henghzhi Yuan, Jeffrey Zhang.\n\n\nILLIXR came together after many consultations with researchers and practitioners in many domains: audio, graphics, optics, robotics, signal processing, and extended reality systems. We are deeply grateful for all of these discussions and specifically to the following: Wei Cu, Aleksandra Faust, Liang Gao, Matt Horsnell, Amit Jindal, Steve LaValle, Steve Lovegrove, Andrew Maimone, Vegard \u00d8ye, Martin Persson, Archontis Politis, Eric Shaffer, Paris Smaragdis, Sachin Talathi, and Chris Widdowson.\n\n\nOur OpenXR implementation is derived from \nMonado\n. We are particularly thankful to Jakob Bornecrantz and Ryan Pavlik.\n\n\nThe development of ILLIXR was supported by the Applications Driving Architectures (ADA) Research Center, a JUMP Center co-sponsored by SRC and DARPA, the Center for Future Architectures Research (C-FAR), one of the six centers of STARnet, a Semiconductor Research Corporation program sponsored by MARCO and DARPA, and by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations from ARM and NVIDIA. Facebook Reality Labs provided the \nOpenEDS Semantic Segmentation Dataset\n.\n\n\nWesley Darvin came up with the name for ILLIXR.\n\n\nLicensing Structure\n\n\nILLIXR is available as open-source software under the \nUniversity of Illinois/NCSA Open Source License\n. As mentioned above, ILLIXR largely consists of components developed by domain experts and modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us. \nThe NCSA license is limited to only this software\n. The external libraries and softwares included in ILLIXR each have their own licenses and must be used according to those licenses:\n\n\n\n\nOpen-VINS\n - \nGNU General Public License v3.0\n\n\nElasticFusion\n - \nElasticFusion license\n\n\nRITnet\n - \nMIT License\n\n\nlibspatialaudio\n - \nGNU Lesser General Public License v2.1\n\n\nHOTlab\n - \nGNU Lesser General Public License v3.0\n\n\nMonado\n - \nBoost Software License 1.0\n\n\n\n\nGet In Touch\n\n\nWhether you are a computer architect, a systems person, an XR application developer, or just anyone interested in XR, we would love to hear your feedback on ILLIXR! ILLIXR is a living testbed and we would like to both refine existing components and add new ones. We believe ILLIXR has the opportunity to drive future computer architecture and systems research for XR, and can benefit from contributions from other researchers and organizations. If you would like to be a part of this effort, please contact us at \nillixr at cs dot illinois dot edu\n or visit us on \nGitter\n or just send us a pull request!",
            "title": "Home"
        },
        {
            "location": "/#illixr",
            "text": "Illinois Extended Reality testbed or ILLIXR (pronounced like elixir) is the first open-source full-system Extended Reality (XR) testbed. It contains standalone state-of-the-art components representative of a generic XR workflow, as well as a runtime framework that integrates these components into an XR system. ILLIXR's runtime integration framework is modular, extensible, and  OpenXR -compatible.  We use the term  components  and not  kernels  or  computations  because each component of ILLIXR is an entire application in itself, and consists of many kernels and computations. At the moment, ILLIXR contains the following state-of-the-art components, all of which can be found packaged together in the  v1-latest release  of ILLIXR.   Simultaneous Localization and Mapping  Scene reconstruction  Eye tracking  Ambisonic encoding  Ambisonic manipulation and binauralization  Lens distortion correction  Chromatic aberration correction  Time warp  Computational holography for adaptive multi-focal displays   We plan on adding more components (e.g., graphics and multiple versions for individual components) and extending the runtime in the future. Our goal is not to create a commercial quality XR product for current hardware. Instead, the goal for ILLIXR is to advance computer architecture, systems, and hardware-software co-design research for XR by making available a full system and key state-of-the-art components of both modern and future XR applications.  Many of the current components of ILLIXR were developed by domain experts and obtained from publicly available repositories. They were modified for one or more of the following reasons: fixing compilation, adding features, or removing extraneous code or dependencies. Each component not developed by us is available as a forked github repository for proper attribution to its authors.  Detailed descriptions of each component and our runtime, including performance and energy profiles, can be found in our  paper .",
            "title": "ILLIXR"
        },
        {
            "location": "/#publications",
            "text": "We request that you cite our following paper (new version coming soon) when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published.  @misc{HuzaifaDesai2020,\n    title={Exploring Extended Reality with ILLIXR: A new Playground for Architecture Research},\n    author={Muhammad Huzaifa and Rishi Desai and Xutao Jiang and Joseph Ravichandran and Finn Sinclair and Sarita V. Adve},\n    year={2020},\n    eprint={2004.04643},\n    primaryClass={cs.DC}\n}",
            "title": "Publications"
        },
        {
            "location": "/#getting-started-and-documentation",
            "text": "For more information, see our  getting started page .",
            "title": "Getting Started and Documentation"
        },
        {
            "location": "/#acknowledgements",
            "text": "Muhammad Huzaifa led the development of ILLIXR in  Sarita Adve\u2019s research group  at the University of Illinois at Urbana-Champaign. Other major contributors include Rishi Desai, Samuel Grayson, Xutao Jiang, Ying Jing, Jae Lee, Fang Lu, Joseph Ravichandran, Finn Sinclair, Henghzhi Yuan, Jeffrey Zhang.  ILLIXR came together after many consultations with researchers and practitioners in many domains: audio, graphics, optics, robotics, signal processing, and extended reality systems. We are deeply grateful for all of these discussions and specifically to the following: Wei Cu, Aleksandra Faust, Liang Gao, Matt Horsnell, Amit Jindal, Steve LaValle, Steve Lovegrove, Andrew Maimone, Vegard \u00d8ye, Martin Persson, Archontis Politis, Eric Shaffer, Paris Smaragdis, Sachin Talathi, and Chris Widdowson.  Our OpenXR implementation is derived from  Monado . We are particularly thankful to Jakob Bornecrantz and Ryan Pavlik.  The development of ILLIXR was supported by the Applications Driving Architectures (ADA) Research Center, a JUMP Center co-sponsored by SRC and DARPA, the Center for Future Architectures Research (C-FAR), one of the six centers of STARnet, a Semiconductor Research Corporation program sponsored by MARCO and DARPA, and by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations from ARM and NVIDIA. Facebook Reality Labs provided the  OpenEDS Semantic Segmentation Dataset .  Wesley Darvin came up with the name for ILLIXR.",
            "title": "Acknowledgements"
        },
        {
            "location": "/#licensing-structure",
            "text": "ILLIXR is available as open-source software under the  University of Illinois/NCSA Open Source License . As mentioned above, ILLIXR largely consists of components developed by domain experts and modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us.  The NCSA license is limited to only this software . The external libraries and softwares included in ILLIXR each have their own licenses and must be used according to those licenses:   Open-VINS  -  GNU General Public License v3.0  ElasticFusion  -  ElasticFusion license  RITnet  -  MIT License  libspatialaudio  -  GNU Lesser General Public License v2.1  HOTlab  -  GNU Lesser General Public License v3.0  Monado  -  Boost Software License 1.0",
            "title": "Licensing Structure"
        },
        {
            "location": "/#get-in-touch",
            "text": "Whether you are a computer architect, a systems person, an XR application developer, or just anyone interested in XR, we would love to hear your feedback on ILLIXR! ILLIXR is a living testbed and we would like to both refine existing components and add new ones. We believe ILLIXR has the opportunity to drive future computer architecture and systems research for XR, and can benefit from contributions from other researchers and organizations. If you would like to be a part of this effort, please contact us at  illixr at cs dot illinois dot edu  or visit us on  Gitter  or just send us a pull request!",
            "title": "Get In Touch"
        },
        {
            "location": "/building_ILLIXR/",
            "text": "Building ILLIXR\n\n\nBasic usage\n\n\n\n\n\n\nEdit \nconfig.yaml\n. See \nrunner/config_schema.yaml\n for the schema definition.\n\n\n\n\n\n\nMake sure you have defined all of the plugins you want with paths that exist.\n\n\n\n\n\n\nCurrently we support the following loaders: \nnative\n (which runs ILLIXR in standalone mode),\n    \ngdb\n (which runs standalone mode in GDB for debugging purposes), and \nmonado\n (which runs an\n    OpenXR application in Monado using ILLIXR as a backend)\n\n\n\n\nIf you want to run with Monado, make sure you define Monado and an OpenXR application in the\n  loader (see \nrunner/config_schema.yaml\n for specifics).\n\n\n\n\n\n\n\n\nPaths are resolved relative to the project root.\n\n\n\n\n\n\nYou can \n!include\n other YAML files (\ndocumentation\n). Consider separating the site-specific\n    configuration options into its own file.\n\n\n\n\n\n\nRun \n./runner.sh config.yaml\n.\n\n\n\n\n\n\nThis compiles whatever plugins and runtime code is necessary and runs the result.\n\n\n\n\n\n\nThis also sets the environment variables properly.\n\n\n\n\n\n\nRationale\n\n\n\n\n\n\nPreviously, we would have to specify which plugins to build and which to run separately, violating\n  \nDRY principle\n.\n\n\n\n\n\n\nPreviously, configuration had to be hard-coded into the component source code, or passed as\n  parsed/unparsed as strings in env-vars on a per-component basis. This gives us a consistent way to\n  deal with all configurations.\n\n\n\n\n\n\nCurrently, plugins are specificed by a path to the directory containing their source code and\n  build system. In the future, the same config file could support HTTP URLs Git URLs\n  (\ngit+https://github.com/username/repo@rev?path=optional/path/within/repo\n), or Zip URLs\n  (\nzip+http://path/to/archive.zip?path=optional/path/within/zip\n), or even Nix URLs (TBD).\n\n\n\n\n\n\nAdding a new plugin (common case)\n\n\nIn the common case, one need only define a \nMakefile\n with the line \ninclude common/common.mk\n and\nsymlink common (\nln -s ../common common\n). This provides the necessary targets and uses the compiler\n\n$(CXX)\n, which is defined in Make based on the OS and environment variables.\n\n\n\n\n\n\nIt compiles \nplugin.cpp\n and any other \n*.cpp\n files into the plugin.\n\n\n\n\n\n\nIt will invoke a recompile the target any time any \n*.hpp\n or \n*.cpp\n file changes.\n\n\n\n\n\n\nIt compiles with C++17. You can change this in your plugin by defining \nSTDCXX = ...\n before the\n  \ninclude\n. This change will not affect other plugins; just yours.\n\n\n\n\n\n\nLibraries can be added by appending to \nLDFLAGS\n and \nCFLAGS\n, for example\n\n\nLDFLAGS := $(LDFLAGS) $(shell pkg-config --ldflags eigen3)\nCFLAGS := $(CFLAGS) $(shell pkg-config --cflags eigen3)\n\n\n\n\n\n\n\nSee the source for the exact flags.\n\n\n\n\n\n\nInserted the path of your directory into the \nplugin\n-list in \nconfig.yaml\n.\n\n\n\n\n\n\nAdding a plugin (general case)\n\n\nEach plugin can have a completely independent build system, as long as:\n- It defines a \nMakefile\n with targets for \nplugin.dbg.so\n, \nplugin.opt.so\n, and \nclean\n. Inside\n  this \nMakefile\n, one can defer to another build system.\n\n\n\n\n\n\nIt's compiler maintains \nABI compatibility\n with the compilers used in every other plugin. Using\n  the same version of Clang or GCC on the same architecture is sufficient for this.\n\n\n\n\n\n\nIt's path is inserted in the root \nconfig.yaml\n, in the \nplugins\n list.\n\n\n\n\n\n\nPhilosophy\n\n\n\n\n\n\nEach plugin should not have to know or care how the others are compiled. In the future, they may\n  even be distributed separately, just as SOs. Therefore, each plugin needs its own build system.\n\n\n\n\n\n\nDespite this per-plugin flexibility, building the 'default' set of ILLIXR plugins should be\n  extremely easy.\n\n\n\n\n\n\nIt should be easy to build in parallel.\n\n\n\n\n\n\nAlways rebuild every time, so the binary is always \"fresh\". This is a great convenience when\n  experimenting. However, this implies that rebuilding must be fast when not much has changed.\n\n\n\n\n\n\nMake is the de facto standard for building C/C++ programs. GNU Make, and the\n  makefile language begets no shortage of problems [\n1\n,\n2\n,\n3\n,\n4\n,\n5\n], but we choose\n  Make for its tradeoff of between simplicity and functionality. What it lacks in functionality\n  (compared to CMake, Ninja, scons, Bazel, Meson) it makes up for in simplicity. It's still the\n  build system in which it is the easiest to invoke arbitrary commands in shell and the easiest to\n  have a \ncommon.mk\n included in each plugin. This decision to use Make should be revisited, when\n  this project outgrows its ability, but for now, Make remains, in our judgement, \nthe best tool for\n  the job\n.",
            "title": "building ILLIXR"
        },
        {
            "location": "/building_ILLIXR/#building-illixr",
            "text": "",
            "title": "Building ILLIXR"
        },
        {
            "location": "/building_ILLIXR/#basic-usage",
            "text": "Edit  config.yaml . See  runner/config_schema.yaml  for the schema definition.    Make sure you have defined all of the plugins you want with paths that exist.    Currently we support the following loaders:  native  (which runs ILLIXR in standalone mode),\n     gdb  (which runs standalone mode in GDB for debugging purposes), and  monado  (which runs an\n    OpenXR application in Monado using ILLIXR as a backend)   If you want to run with Monado, make sure you define Monado and an OpenXR application in the\n  loader (see  runner/config_schema.yaml  for specifics).     Paths are resolved relative to the project root.    You can  !include  other YAML files ( documentation ). Consider separating the site-specific\n    configuration options into its own file.    Run  ./runner.sh config.yaml .    This compiles whatever plugins and runtime code is necessary and runs the result.    This also sets the environment variables properly.",
            "title": "Basic usage"
        },
        {
            "location": "/building_ILLIXR/#rationale",
            "text": "Previously, we would have to specify which plugins to build and which to run separately, violating\n   DRY principle .    Previously, configuration had to be hard-coded into the component source code, or passed as\n  parsed/unparsed as strings in env-vars on a per-component basis. This gives us a consistent way to\n  deal with all configurations.    Currently, plugins are specificed by a path to the directory containing their source code and\n  build system. In the future, the same config file could support HTTP URLs Git URLs\n  ( git+https://github.com/username/repo@rev?path=optional/path/within/repo ), or Zip URLs\n  ( zip+http://path/to/archive.zip?path=optional/path/within/zip ), or even Nix URLs (TBD).",
            "title": "Rationale"
        },
        {
            "location": "/building_ILLIXR/#adding-a-new-plugin-common-case",
            "text": "In the common case, one need only define a  Makefile  with the line  include common/common.mk  and\nsymlink common ( ln -s ../common common ). This provides the necessary targets and uses the compiler $(CXX) , which is defined in Make based on the OS and environment variables.    It compiles  plugin.cpp  and any other  *.cpp  files into the plugin.    It will invoke a recompile the target any time any  *.hpp  or  *.cpp  file changes.    It compiles with C++17. You can change this in your plugin by defining  STDCXX = ...  before the\n   include . This change will not affect other plugins; just yours.    Libraries can be added by appending to  LDFLAGS  and  CFLAGS , for example  LDFLAGS := $(LDFLAGS) $(shell pkg-config --ldflags eigen3)\nCFLAGS := $(CFLAGS) $(shell pkg-config --cflags eigen3)    See the source for the exact flags.    Inserted the path of your directory into the  plugin -list in  config.yaml .",
            "title": "Adding a new plugin (common case)"
        },
        {
            "location": "/building_ILLIXR/#adding-a-plugin-general-case",
            "text": "Each plugin can have a completely independent build system, as long as:\n- It defines a  Makefile  with targets for  plugin.dbg.so ,  plugin.opt.so , and  clean . Inside\n  this  Makefile , one can defer to another build system.    It's compiler maintains  ABI compatibility  with the compilers used in every other plugin. Using\n  the same version of Clang or GCC on the same architecture is sufficient for this.    It's path is inserted in the root  config.yaml , in the  plugins  list.",
            "title": "Adding a plugin (general case)"
        },
        {
            "location": "/building_ILLIXR/#philosophy",
            "text": "Each plugin should not have to know or care how the others are compiled. In the future, they may\n  even be distributed separately, just as SOs. Therefore, each plugin needs its own build system.    Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins should be\n  extremely easy.    It should be easy to build in parallel.    Always rebuild every time, so the binary is always \"fresh\". This is a great convenience when\n  experimenting. However, this implies that rebuilding must be fast when not much has changed.    Make is the de facto standard for building C/C++ programs. GNU Make, and the\n  makefile language begets no shortage of problems [ 1 , 2 , 3 , 4 , 5 ], but we choose\n  Make for its tradeoff of between simplicity and functionality. What it lacks in functionality\n  (compared to CMake, Ninja, scons, Bazel, Meson) it makes up for in simplicity. It's still the\n  build system in which it is the easiest to invoke arbitrary commands in shell and the easiest to\n  have a  common.mk  included in each plugin. This decision to use Make should be revisited, when\n  this project outgrows its ability, but for now, Make remains, in our judgement,  the best tool for\n  the job .",
            "title": "Philosophy"
        },
        {
            "location": "/default_plugins/",
            "text": "Default Plugins\n\n\n\n\n\n\noffline_imu_cam\n: Reads IMU data and images from files on disk, emulating a real sensor on the\n  headset (feeds input measurements with timing similar to an actual IMU).\n\n\n\n\n\n\nground_truth_slam\n: Reads the ground-truth from the same dataset to compare our output against\n  (uses timing from \noffline_imu_cam\n).\n\n\n\n\n\n\nopen_vins\n: Runs OpenVINS (\nupstream\n) on the input, and outputs a the headset's pose. In practice, this\n  publishes a fairly slow pose, so pose prediction is required to infer a fast pose. We do not yet\n  have pose prediction, so we say \nopen_vins\n also publishes a fast pose.\n\n\n\n\n\n\ngldemo\n: Renders a static scene (into left and right eyebuffers) given the pose from \nopen_vins\n.\n\n\n\n\n\n\ntimewarp_gl\n: \nAsynchronous reprojection\n of the eyebuffers.\n\n\n\n\n\n\ndebugview\n: Renders a frame for debug information.\n\n\n\n\n\n\naudio\n: TODO: this. By default this is disabled, since it requires an NVIDIA GPU.\n\n\n\n\n\n\nhologram\n: TODO: this. By default this is disabled, since it requires an NVIDIA GPU.\n\n\n\n\n\n\nBelow this point, we will use Switchboard terminology. Read the \nAPI documentation on \nswitchboard\n for definitions.\n\n\n\n\n\n\n\n\nIn the above figure, rectangles are plugins, cylinders are topics (the graph is bipartitioned\n  between these two gorups).\n\n\n\n\n\n\nSolid arrows from plugins to topics represent publishing.\n\n\n\n\n\n\nSolid arrows from topics to plugins represent synchronous reading. They take some action for\n  \nevery\n event which gets published on the topic.\n\n\n\n\n\n\nSolid arrows from topics to plugins represent asynchronous reading. They need to know just the\n  \nlatest\n event on their topic.\n\n\n\n\n\n\nImagine the topic as a trough filing with events from its publisher, being drained by its\n  synchronous readers (AKA subscribers), while asynchronous readres just skim from the top.\n\n\n\n\n\n\nSee \nWriting Your Plugin\n to extend ILLIXR.",
            "title": "Default plugins"
        },
        {
            "location": "/default_plugins/#default-plugins",
            "text": "offline_imu_cam : Reads IMU data and images from files on disk, emulating a real sensor on the\n  headset (feeds input measurements with timing similar to an actual IMU).    ground_truth_slam : Reads the ground-truth from the same dataset to compare our output against\n  (uses timing from  offline_imu_cam ).    open_vins : Runs OpenVINS ( upstream ) on the input, and outputs a the headset's pose. In practice, this\n  publishes a fairly slow pose, so pose prediction is required to infer a fast pose. We do not yet\n  have pose prediction, so we say  open_vins  also publishes a fast pose.    gldemo : Renders a static scene (into left and right eyebuffers) given the pose from  open_vins .    timewarp_gl :  Asynchronous reprojection  of the eyebuffers.    debugview : Renders a frame for debug information.    audio : TODO: this. By default this is disabled, since it requires an NVIDIA GPU.    hologram : TODO: this. By default this is disabled, since it requires an NVIDIA GPU.    Below this point, we will use Switchboard terminology. Read the  API documentation on  switchboard  for definitions.     In the above figure, rectangles are plugins, cylinders are topics (the graph is bipartitioned\n  between these two gorups).    Solid arrows from plugins to topics represent publishing.    Solid arrows from topics to plugins represent synchronous reading. They take some action for\n   every  event which gets published on the topic.    Solid arrows from topics to plugins represent asynchronous reading. They need to know just the\n   latest  event on their topic.    Imagine the topic as a trough filing with events from its publisher, being drained by its\n  synchronous readers (AKA subscribers), while asynchronous readres just skim from the top.    See  Writing Your Plugin  to extend ILLIXR.",
            "title": "Default Plugins"
        },
        {
            "location": "/getting_started/",
            "text": "Getting Started\n\n\nILLIXR Runtime\n\n\nThese instructions have been tested with Ubuntu 18.10.\n\n\n\n\n\n\nClone the repository:\n\n\ngit clone --recursive --branch v2-latest https://github.com/ILLIXR/ILLIXR\n\n\n\n\n\n\n\nUpdate the submodules. Submodules are git repositories inside a git repository that need to be\n   pulled down separately:\n\n\ngit submodule update --init --recursive\n\n\n\n\n\n\n\nInstall dependencies. This script installs some Ubuntu/Debian packages and builds a specific\n   version of OpenCV from source:\n\n\n./install_deps.sh\n\n\n\n\n\n\n\nInspect \nconfig.yaml\n. The schema definition (with documentation inline) is in \nrunner/config_schema.yaml\n.\n\n\n\n\n\n\nBuild and run ILLIXR standalone:\n\n\n./runner.sh config.yaml\n\n\n\n\n\n\n\nILLIXR Runtime with Monado (supports OpenXR)\n\n\nILLIXR leverages \nMonado\n, an open-source implementation of \nOpenXR\n, to support a wide range\nof applications.  Monado only supports Ubuntu 18.10, because of a low-level driver issue.\n\n\n\n\n\n\nClone Monado:\n\n\ngit clone https://github.com/ILLIXR/monado_integration.git\n\n\n\n\n\n\n\nClone our application example:\n\n\ngit clone https://gitlab.freedesktop.org/monado/demos/openxr-simple-example\n\n\n\n\n\n\n\nClone ILLIXR:\n\n\ngit clone --recursive --branch v2-latest https://github.com/ILLIXR/ILLIXR\ngit submodule update --init --recursive\n\n\n\n\n\n\n\nInstall dependencies:\n\n\ncd ILLIXR\n./install_deps.sh\n\n\n\n\n\n\n\nEdit the \nconig.yaml\n, using this for the loader:\n\n\n\n\n\n\nloader:\n  name: monado\n  monado:\n    path: ../monado_integration\n  openxr_app:\n    path: ../Monado_OpenXR_Simple_Example\n\n\n\n\n\n\nCompile and run:\n./runner.sh config.yaml\n\n\n\n\n\n\n\nILLIXR Standalone\n\n\nILLIXR can also benchmark each component in isolation.\n\n\n\n\n\n\nClone the repository.\n\n\ngit clone --recursive --branch v1-latest https://github.com/ILLIXR/ILLIXR\n\n\n\n\n\n\n\nUpdate the submodules. Submodules are git repositories inside a git repository that need to be\n   pulled down separately.\n\n\ngit submodule update --init --recursive\n\n\n\n\n\n\n\nEach component is a directory in \nbenchmark\n. See those components for their documentation.\n\n\n\n\n\n\nNext steps\n\n\nThe source code is divided into the following directories:\n- \nruntime\n: create a runnable binary that loads every plugin.\n    * This contains Spindle, which is responsible for loading plugins.\n\n\n\n\n\n\ncommon\n: resources one might use in each plugin. Most plugins symlink this directory into theirs.\n\n\n\n\nContains the interface for Switchboard, which maintains event-streams (implementation is in \nruntime\n).\n\n\nContains the interface for Phonebook, which is a service-directory (implementation is in \nruntime\n).\n\n\n\n\n\n\n\n\na directory for each plugin. Almost all of the XR functionality is implemented in plugins. See\n  \nDefault Components\n for more details.\n\n\n\n\n\n\nTry browsing the source of plugins.  If you edit any of the source files, this make commend will\ndetect and rebuild the respective binary. If you want to add your own, see \nWriting Your Plugin\n.",
            "title": "Getting started"
        },
        {
            "location": "/getting_started/#getting-started",
            "text": "",
            "title": "Getting Started"
        },
        {
            "location": "/getting_started/#illixr-runtime",
            "text": "These instructions have been tested with Ubuntu 18.10.    Clone the repository:  git clone --recursive --branch v2-latest https://github.com/ILLIXR/ILLIXR    Update the submodules. Submodules are git repositories inside a git repository that need to be\n   pulled down separately:  git submodule update --init --recursive    Install dependencies. This script installs some Ubuntu/Debian packages and builds a specific\n   version of OpenCV from source:  ./install_deps.sh    Inspect  config.yaml . The schema definition (with documentation inline) is in  runner/config_schema.yaml .    Build and run ILLIXR standalone:  ./runner.sh config.yaml",
            "title": "ILLIXR Runtime"
        },
        {
            "location": "/getting_started/#illixr-runtime-with-monado-supports-openxr",
            "text": "ILLIXR leverages  Monado , an open-source implementation of  OpenXR , to support a wide range\nof applications.  Monado only supports Ubuntu 18.10, because of a low-level driver issue.    Clone Monado:  git clone https://github.com/ILLIXR/monado_integration.git    Clone our application example:  git clone https://gitlab.freedesktop.org/monado/demos/openxr-simple-example    Clone ILLIXR:  git clone --recursive --branch v2-latest https://github.com/ILLIXR/ILLIXR\ngit submodule update --init --recursive    Install dependencies:  cd ILLIXR\n./install_deps.sh    Edit the  conig.yaml , using this for the loader:    loader:\n  name: monado\n  monado:\n    path: ../monado_integration\n  openxr_app:\n    path: ../Monado_OpenXR_Simple_Example   Compile and run: ./runner.sh config.yaml",
            "title": "ILLIXR Runtime with Monado (supports OpenXR)"
        },
        {
            "location": "/getting_started/#illixr-standalone",
            "text": "ILLIXR can also benchmark each component in isolation.    Clone the repository.  git clone --recursive --branch v1-latest https://github.com/ILLIXR/ILLIXR    Update the submodules. Submodules are git repositories inside a git repository that need to be\n   pulled down separately.  git submodule update --init --recursive    Each component is a directory in  benchmark . See those components for their documentation.",
            "title": "ILLIXR Standalone"
        },
        {
            "location": "/getting_started/#next-steps",
            "text": "The source code is divided into the following directories:\n-  runtime : create a runnable binary that loads every plugin.\n    * This contains Spindle, which is responsible for loading plugins.    common : resources one might use in each plugin. Most plugins symlink this directory into theirs.   Contains the interface for Switchboard, which maintains event-streams (implementation is in  runtime ).  Contains the interface for Phonebook, which is a service-directory (implementation is in  runtime ).     a directory for each plugin. Almost all of the XR functionality is implemented in plugins. See\n   Default Components  for more details.    Try browsing the source of plugins.  If you edit any of the source files, this make commend will\ndetect and rebuild the respective binary. If you want to add your own, see  Writing Your Plugin .",
            "title": "Next steps"
        },
        {
            "location": "/monado_illixr_runtime_overview/",
            "text": "Monado Integration Overview\n\n\nILLIXR's plugins provide XR services, and the runtime ties them together. However, we don't want to\nforce developers to write \ntheir wohle application\n specifically for ILLIXR. As such, we want to\nimplement a common interface XR runtimes, such as \nOpenXR\n, so one application can work on\nseveral runtimes (including ours). In order to support OpenXR, we modified \nMonado\n, an existing,\nopen-source implementation.\n\n\n\n\n\n\nWhen running ILLIXR without Monado, the Illixr runtime is the entry-point. Phonebook and\n  switchboard are initialized and plugins are loaded, among which is the gldemo app.\n\n\n\n\n\n\nWhen running from Monado, however, as mandated by OpenXR specifications, the application is the\n  entry point. As a result, the Illixr runtime system is loaded at a later point as a shared\n  library. This article documents the changes to the Illixr runtime when an OpenXR application is\n  used.\n\n\n\n\n\n\n1. App launches and brings up Monado\n\n\nAs specified by OpenXR, the OpenXR application initializes the OpenXR runtime by reading a\nconfiguration JSON file pointed to by an environment variable and loads the OpenXR runtime, which is\nMonado in this case, as a shared library into its address space. Consult the OpenXR specifications\nand the OpenXR-SDK from Khronous Group for more details.\n\n\n2.  Monado probes HMD devices and Illixr Initializes\n\n\nDuring initialization, Monado asks all drivers to probe for and initialize HMDs and controllers,\ninternally known as \nxdev\ns.  We have an Illixr driver, which will always respond to Monado with one\ndiscovered HMD that will be used to capture OpenXR queries and events from Monado's state\ntracker. The Illixr driver obtains the path to the Illixr runtime so file and a list of plugins from\nenvironment variables.\n\n\nAfter probing is finished, the application will start to create an OpenXR session. At some point in\nthis process, the application will send its rendering context to the runtime, which we capture and\nsend to the Illixr driver. At this moment, all necessary data is ready and Illixr will be launched.\n\n\n3. Illixr Runtime Launch\n\n\nWhen used with Monado, the Illixr runtime is compiled into a shared library instead of an\nexecutable. The library exports its two major functionalities: initializing switchboard and\nphonebook, and load plugins.\n\n\nThe drivers starts to load the runtime by loading the shared library into the current (the app's)\naddress space and calls the switchboard and phonebook initialization. Then, it calls the plugin\nloading for each Illixr plugin (except gldemo, which is replaced by the OpenXR app). Finally, it\ncalls a special plugin loading which takes a function address instead of a file path to load a\ntranslation plugin into Illixr as the application. The translation plugin will be in the next\nsection. Each plugin should either not block or start its own thread, so the driver will be able to\nreacquire control and return to Monado and the app shortly.\n\n\n4. The translation plugin\n\n\nWhen the app and all Illixr plugins are up and running, the translation plugin handles the\nconnection between Monado and Illixr. It might be confusing to see that this plugin is part of the\nIllixr driver which is part of Monado while at the same time also part of Illixr as a plugin. But\nMonado and Illixr are running in different threads in the same address space. The translation plugin\nis the intersection of these two parallel systems serving as a bridge between the two.\n\n\nThe translation plugin handles two types of events at the moment: pose requests and frame\nsubmissions. From the view of Monado, it is the destination of all requests: from the application,\nto Monado's state trackers, to the xdev interface who is responsible for servicing the request. From\nthe view of Illixr, it behaves the same as the gldemo app: reading pose and submitting frames.\n\n\nFor implementation details regarding the representation of poses and frames in Monado and in Illixr,\nplease see Monado Integration Dataflow.",
            "title": "Monado illixr runtime overview"
        },
        {
            "location": "/monado_illixr_runtime_overview/#monado-integration-overview",
            "text": "ILLIXR's plugins provide XR services, and the runtime ties them together. However, we don't want to\nforce developers to write  their wohle application  specifically for ILLIXR. As such, we want to\nimplement a common interface XR runtimes, such as  OpenXR , so one application can work on\nseveral runtimes (including ours). In order to support OpenXR, we modified  Monado , an existing,\nopen-source implementation.    When running ILLIXR without Monado, the Illixr runtime is the entry-point. Phonebook and\n  switchboard are initialized and plugins are loaded, among which is the gldemo app.    When running from Monado, however, as mandated by OpenXR specifications, the application is the\n  entry point. As a result, the Illixr runtime system is loaded at a later point as a shared\n  library. This article documents the changes to the Illixr runtime when an OpenXR application is\n  used.",
            "title": "Monado Integration Overview"
        },
        {
            "location": "/monado_illixr_runtime_overview/#1-app-launches-and-brings-up-monado",
            "text": "As specified by OpenXR, the OpenXR application initializes the OpenXR runtime by reading a\nconfiguration JSON file pointed to by an environment variable and loads the OpenXR runtime, which is\nMonado in this case, as a shared library into its address space. Consult the OpenXR specifications\nand the OpenXR-SDK from Khronous Group for more details.",
            "title": "1. App launches and brings up Monado"
        },
        {
            "location": "/monado_illixr_runtime_overview/#2-monado-probes-hmd-devices-and-illixr-initializes",
            "text": "During initialization, Monado asks all drivers to probe for and initialize HMDs and controllers,\ninternally known as  xdev s.  We have an Illixr driver, which will always respond to Monado with one\ndiscovered HMD that will be used to capture OpenXR queries and events from Monado's state\ntracker. The Illixr driver obtains the path to the Illixr runtime so file and a list of plugins from\nenvironment variables.  After probing is finished, the application will start to create an OpenXR session. At some point in\nthis process, the application will send its rendering context to the runtime, which we capture and\nsend to the Illixr driver. At this moment, all necessary data is ready and Illixr will be launched.",
            "title": "2.  Monado probes HMD devices and Illixr Initializes"
        },
        {
            "location": "/monado_illixr_runtime_overview/#3-illixr-runtime-launch",
            "text": "When used with Monado, the Illixr runtime is compiled into a shared library instead of an\nexecutable. The library exports its two major functionalities: initializing switchboard and\nphonebook, and load plugins.  The drivers starts to load the runtime by loading the shared library into the current (the app's)\naddress space and calls the switchboard and phonebook initialization. Then, it calls the plugin\nloading for each Illixr plugin (except gldemo, which is replaced by the OpenXR app). Finally, it\ncalls a special plugin loading which takes a function address instead of a file path to load a\ntranslation plugin into Illixr as the application. The translation plugin will be in the next\nsection. Each plugin should either not block or start its own thread, so the driver will be able to\nreacquire control and return to Monado and the app shortly.",
            "title": "3. Illixr Runtime Launch"
        },
        {
            "location": "/monado_illixr_runtime_overview/#4-the-translation-plugin",
            "text": "When the app and all Illixr plugins are up and running, the translation plugin handles the\nconnection between Monado and Illixr. It might be confusing to see that this plugin is part of the\nIllixr driver which is part of Monado while at the same time also part of Illixr as a plugin. But\nMonado and Illixr are running in different threads in the same address space. The translation plugin\nis the intersection of these two parallel systems serving as a bridge between the two.  The translation plugin handles two types of events at the moment: pose requests and frame\nsubmissions. From the view of Monado, it is the destination of all requests: from the application,\nto Monado's state trackers, to the xdev interface who is responsible for servicing the request. From\nthe view of Illixr, it behaves the same as the gldemo app: reading pose and submitting frames.  For implementation details regarding the representation of poses and frames in Monado and in Illixr,\nplease see Monado Integration Dataflow.",
            "title": "4. The translation plugin"
        },
        {
            "location": "/monado_integration_dataflow/",
            "text": "Monado Integration Dataflow\n\n\nThe integration for monado in terms of dataflow can be divided into two parts, getting pose from\nillixr, and sending user rendered frame to illixr.\n\n\nIn monado, illixr looks like an HMD for monado, while in illixr, monado looks like a user\napplication as \ngldemo\n. After illixr is initialized from monado, and monado is registered as a\nplugin for illixr, most recent pose information is easy to get from switchboard.\n\n\nThe compositor side of monado integration with illixr is done in more subtle way. Original monado\ncompositor mostly does distortion correction and aberration correction in a vulkan back-end\ncompositor. It also has two client compositor, one for opengl app, the other for vulkan app, which\npass frame data to the back-end compositor. Illixr integration intercepts the frame at gl client\ncompositor and sends it to switchboard of illixr, which is then used by \ntimewarp_gl\n component.\n\n\nIn order to get a opengl frame and use it without copying pixels, illixr needs to get the user\napplication gl context. It is done at OpenXR session creation time, where illixr is\ninitialized. Note that logically illixr is initialized during OpenXR instance creation, or running\nat the background all the time. But, since illixr only supports single session at this time, and\nrequires a user application gl context upon initialization, illixr is initialized at session\ncreation time.\n\n\nCurrent illixr integration for monado is a temporary solution and has some downsides because of the\nprogress from both monado and illixr.\n\n\n\n\n\n\nIt does not use the pose that user application declares to use at rendering (OpenXR\n   specification) because of monado internal interfaces. The pose difference used by timewarp comes\n   from the last pose query call.\n\n\n\n\n\n\nIt cannot submit frame with depth buffer.\n\n\n\n\n\n\nThe pose from illixr does not vary according to the OpenXR space. It is a raw pose data from slam\n   algorithms.\n\n\n\n\n\n\nNo controller action support at all.\n\n\n\n\n\n\nIt only supports gl user applications.\n\n\n\n\n\n\nUser application cannot acquire more than one swapchain image (for each eye) in one frame.\n\n\n\n\n\n\nIllixr is initialized during session creation time.",
            "title": "Monado integration dataflow"
        },
        {
            "location": "/monado_integration_dataflow/#monado-integration-dataflow",
            "text": "The integration for monado in terms of dataflow can be divided into two parts, getting pose from\nillixr, and sending user rendered frame to illixr.  In monado, illixr looks like an HMD for monado, while in illixr, monado looks like a user\napplication as  gldemo . After illixr is initialized from monado, and monado is registered as a\nplugin for illixr, most recent pose information is easy to get from switchboard.  The compositor side of monado integration with illixr is done in more subtle way. Original monado\ncompositor mostly does distortion correction and aberration correction in a vulkan back-end\ncompositor. It also has two client compositor, one for opengl app, the other for vulkan app, which\npass frame data to the back-end compositor. Illixr integration intercepts the frame at gl client\ncompositor and sends it to switchboard of illixr, which is then used by  timewarp_gl  component.  In order to get a opengl frame and use it without copying pixels, illixr needs to get the user\napplication gl context. It is done at OpenXR session creation time, where illixr is\ninitialized. Note that logically illixr is initialized during OpenXR instance creation, or running\nat the background all the time. But, since illixr only supports single session at this time, and\nrequires a user application gl context upon initialization, illixr is initialized at session\ncreation time.  Current illixr integration for monado is a temporary solution and has some downsides because of the\nprogress from both monado and illixr.    It does not use the pose that user application declares to use at rendering (OpenXR\n   specification) because of monado internal interfaces. The pose difference used by timewarp comes\n   from the last pose query call.    It cannot submit frame with depth buffer.    The pose from illixr does not vary according to the OpenXR space. It is a raw pose data from slam\n   algorithms.    No controller action support at all.    It only supports gl user applications.    User application cannot acquire more than one swapchain image (for each eye) in one frame.    Illixr is initialized during session creation time.",
            "title": "Monado Integration Dataflow"
        },
        {
            "location": "/visualizer_logger/",
            "text": "Visualizer & Logger\n\n\nThere is a utility header file \ncommon/logger.hpp\n, which is a logger for recording process starting\nand ending time, with respect to the component initialization time. Currently, only \naudio_pipeline\n\nand \nhologram\nuse this logger. Please create a \nlog\n directory in your running binary directory to\nlet those log files correctly appear.\n\n\nlog/visualizer.py\nis a script to create visual timeline according to the log files in the same\ndirectory. It is not convenient to use or precisely correct right now.",
            "title": "Visualizer logger"
        },
        {
            "location": "/visualizer_logger/#visualizer-logger",
            "text": "There is a utility header file  common/logger.hpp , which is a logger for recording process starting\nand ending time, with respect to the component initialization time. Currently, only  audio_pipeline \nand  hologram use this logger. Please create a  log  directory in your running binary directory to\nlet those log files correctly appear.  log/visualizer.py is a script to create visual timeline according to the log files in the same\ndirectory. It is not convenient to use or precisely correct right now.",
            "title": "Visualizer &amp; Logger"
        },
        {
            "location": "/writing_your_plugin/",
            "text": "Writing your plugin\n\n\nWith this, you can extend ILLIXR for your own purposes. You can also replace any existing\nfunctionality this way.\n\n\n\n\n\n\nWe suggest making a subdirectory in the ILLIXR repo, but one could make it anywhere.\n\n\n\n\n\n\nAdd this directory to \nplugins\n in ILLIXR's root \nMakefile\n. The order in this list determines\n   the order of initialization in the program. \nphonebook\n, for example, is order-sensitive.\n\n\n\n\n\n\nIn your plugin directory, we suggest symlinking common (\nln -s ../common common\n).\n\n\n\n\n\n\nCreate a \nMakefile\n with the following contents. See \nBuilding ILLIXR\n for more details and alternative setups.\n\n\ninclude common.mk\n\n\n\n\n\n\n\nYou must decide if your plugin should inherit the standardized \nthreadloop\n or\n    \nplugin\n.\n\n\n\n\n\n\nIf your plugin just needs to run one computation repeatedly, then your plugin class should\n    extend \nthreadloop\n.\n\n\n\n\n\n\nIf you need custom concurrency (more complicated than a loop), triggered concurrency (by\n    events fired in other plugins), or no concurrency then your plugin class should extend\n    \nplugin\n.\n\n\n\n\n\n\nWrite a file called \nplugin.cpp\n with this body, replacing every instance of \nplugin_name\n:\n\n\n#include \"common/phonebook.hpp\"\n#include \"common/plugin.hpp\"\n#include \"common/threadloop.hpp\"\n\nusing namespace ILLIXR;\n\n// Inherit from `plugin` if you don't need the threadloop\nclass plugin_name : public threadloop {\npublic:\n    plugin_name(std::string name_, phonebook* pb_)\n        : threadloop{name_, pb_}\n        { }\n    virtual void start() override { }\n    virtual ~plugin_name() override { }\n};\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(plugin_name);\n\n\n\n\n\n\n\nAt this point, you should be able to go to the ILLIXR root and \nmake dbg\n. If you edit a source\n    file and then \nmake dbg\n, it should trigger a rebuild of your plugin.\n\n\n\n\n\n\nThis is all that is required to be a plugin which can be loaded by Spindle in the ILLIXR\n    runtime. Reading and writing from Phonebook and Switchboard optional, but nearly every plugin\n    does it. See \ndefault_plugins.md\n for more details.\n\n\nFirst, we can query the \nphonebook\n to get various services including \nswitchboard\n. Then we\nquery \nswitchboard\n for event-streams (topics). We will read \ntopic1\n, write to \ntopic2\n, and\nschedule computation on \ntopic 3\n. See the API documentation for \nphonebook\n and \nswitchboard\n\nfor more details.\n\n\n#include \"common/phonebook.hpp\"\n#include \"common/plugin.hpp\"\n#include \"common/threadloop.hpp\"\n\n/* When datatypes have to be common across plugins\n  (e.g. a phonebook service or switchboard topic),\n   they are defined in this header,\n   which is accessible to all plugins. */\n#include \"common/data_format.hpp\"\n\nclass plugin_name : public threadloop {\npublic:\n    /*\n        After the constructor, C++ permits a list of member-constructors.\n        We use uniform initialization (curly-braces) [1] instead of parens to avoid ambiguity [2].\n        We put the comma at the start of the line, so that lines can be copied around or deleted freely (except for the first).\n\n        [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization\n        [2]: https://en.wikipedia.org/wiki/Most_vexing_parse\n    */\n    plugin_name(std::string name_, phonebook* pb_)\n        : threadloop{name_, pb_}\n          // find the switchboard in phonebook\n        , sb{pb->lookup_impl<switchboard>()}\n          // create a handle to a topic in switchboard for subscribing\n        , topic1{sb->subscribe_latest<topic1_type>(\"topic1\")}\n          // create a handle to a topic in switchboard for publishing\n        , topic2{sb->publish<topic2_type>(\"topic2\")}\n    {\n        // Read topic 1\n        topic1_type* event1 = topic1.get_latest_ro();\n\n        // Write to topic 2\n        topic2_type* event2 = new topic2_type;\n        topic2.put(event2);\n\n        // Read topic 3 synchronously\n        sb->schedule<topic3_type>(get_name(), \"topic3\", [&](const topic3_type *event3) {\n            /*\n            This is a [lambda expression][1]\n            [1]: https://en.cppreference.com/w/cpp/language/lambda\n            */\n            std::cout << \"Got a new event on topic3: \" << event3 << std::endl;\n        });\n    }\n\n    virtual void _p_one_iteration override() {\n        std::cout << \"Running\" << std::endl;\n        auto target = std::chrono::high_resolution_clock::now() +  std::chrono::milliseconds{10};\n        reliable_sleep(target);\n    }\n\nprivate:\n    const std::shared_ptr<switchboard> pb;\n    std::unique_ptr<reader_latest<topic1_type>> topic1;\n    std::unique_ptr<writer<topic2>> topic2;\n};\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(plugin_name);",
            "title": "Writing your plugin"
        },
        {
            "location": "/writing_your_plugin/#writing-your-plugin",
            "text": "With this, you can extend ILLIXR for your own purposes. You can also replace any existing\nfunctionality this way.    We suggest making a subdirectory in the ILLIXR repo, but one could make it anywhere.    Add this directory to  plugins  in ILLIXR's root  Makefile . The order in this list determines\n   the order of initialization in the program.  phonebook , for example, is order-sensitive.    In your plugin directory, we suggest symlinking common ( ln -s ../common common ).    Create a  Makefile  with the following contents. See  Building ILLIXR  for more details and alternative setups.  include common.mk    You must decide if your plugin should inherit the standardized  threadloop  or\n     plugin .    If your plugin just needs to run one computation repeatedly, then your plugin class should\n    extend  threadloop .    If you need custom concurrency (more complicated than a loop), triggered concurrency (by\n    events fired in other plugins), or no concurrency then your plugin class should extend\n     plugin .    Write a file called  plugin.cpp  with this body, replacing every instance of  plugin_name :  #include \"common/phonebook.hpp\"\n#include \"common/plugin.hpp\"\n#include \"common/threadloop.hpp\"\n\nusing namespace ILLIXR;\n\n// Inherit from `plugin` if you don't need the threadloop\nclass plugin_name : public threadloop {\npublic:\n    plugin_name(std::string name_, phonebook* pb_)\n        : threadloop{name_, pb_}\n        { }\n    virtual void start() override { }\n    virtual ~plugin_name() override { }\n};\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(plugin_name);    At this point, you should be able to go to the ILLIXR root and  make dbg . If you edit a source\n    file and then  make dbg , it should trigger a rebuild of your plugin.    This is all that is required to be a plugin which can be loaded by Spindle in the ILLIXR\n    runtime. Reading and writing from Phonebook and Switchboard optional, but nearly every plugin\n    does it. See  default_plugins.md  for more details.  First, we can query the  phonebook  to get various services including  switchboard . Then we\nquery  switchboard  for event-streams (topics). We will read  topic1 , write to  topic2 , and\nschedule computation on  topic 3 . See the API documentation for  phonebook  and  switchboard \nfor more details.  #include \"common/phonebook.hpp\"\n#include \"common/plugin.hpp\"\n#include \"common/threadloop.hpp\"\n\n/* When datatypes have to be common across plugins\n  (e.g. a phonebook service or switchboard topic),\n   they are defined in this header,\n   which is accessible to all plugins. */\n#include \"common/data_format.hpp\"\n\nclass plugin_name : public threadloop {\npublic:\n    /*\n        After the constructor, C++ permits a list of member-constructors.\n        We use uniform initialization (curly-braces) [1] instead of parens to avoid ambiguity [2].\n        We put the comma at the start of the line, so that lines can be copied around or deleted freely (except for the first).\n\n        [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization\n        [2]: https://en.wikipedia.org/wiki/Most_vexing_parse\n    */\n    plugin_name(std::string name_, phonebook* pb_)\n        : threadloop{name_, pb_}\n          // find the switchboard in phonebook\n        , sb{pb->lookup_impl<switchboard>()}\n          // create a handle to a topic in switchboard for subscribing\n        , topic1{sb->subscribe_latest<topic1_type>(\"topic1\")}\n          // create a handle to a topic in switchboard for publishing\n        , topic2{sb->publish<topic2_type>(\"topic2\")}\n    {\n        // Read topic 1\n        topic1_type* event1 = topic1.get_latest_ro();\n\n        // Write to topic 2\n        topic2_type* event2 = new topic2_type;\n        topic2.put(event2);\n\n        // Read topic 3 synchronously\n        sb->schedule<topic3_type>(get_name(), \"topic3\", [&](const topic3_type *event3) {\n            /*\n            This is a [lambda expression][1]\n            [1]: https://en.cppreference.com/w/cpp/language/lambda\n            */\n            std::cout << \"Got a new event on topic3: \" << event3 << std::endl;\n        });\n    }\n\n    virtual void _p_one_iteration override() {\n        std::cout << \"Running\" << std::endl;\n        auto target = std::chrono::high_resolution_clock::now() +  std::chrono::milliseconds{10};\n        reliable_sleep(target);\n    }\n\nprivate:\n    const std::shared_ptr<switchboard> pb;\n    std::unique_ptr<reader_latest<topic1_type>> topic1;\n    std::unique_ptr<writer<topic2>> topic2;\n};\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(plugin_name);",
            "title": "Writing your plugin"
        }
    ]
}